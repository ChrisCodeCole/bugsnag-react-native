{"version":3,"sources":["/Users/jamielynch/repos/bugsnag-react-native/examples/plain/node_modules/react-native/Libraries/Core/Timers/JSTimers.js"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n'use strict';\n\nconst Platform = require('Platform');\nconst Systrace = require('Systrace');\n\nconst invariant = require('fbjs/lib/invariant');\nconst {Timing} = require('NativeModules');\nconst BatchedBridge = require('BatchedBridge');\n\nimport type {ExtendedError} from 'parseErrorStack';\n\nlet _performanceNow = null;\nfunction performanceNow() {\n  if (!_performanceNow) {\n    /* $FlowFixMe(>=0.54.0 site=react_native_oss) This comment suppresses an\n     * error found when Flow v0.54 was deployed. To see the error delete this\n     * comment and run Flow. */\n    _performanceNow = require('fbjs/lib/performanceNow');\n  }\n  return _performanceNow();\n}\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\n\nexport type JSTimerType =\n  | 'setTimeout'\n  | 'setInterval'\n  | 'requestAnimationFrame'\n  | 'setImmediate'\n  | 'requestIdleCallback';\n\n// These timing constants should be kept in sync with the ones in native ios and\n// android `RCTTiming` module.\nconst FRAME_DURATION = 1000 / 60;\nconst IDLE_CALLBACK_FRAME_DEADLINE = 1;\n\nconst MAX_TIMER_DURATION_MS = 60 * 1000;\nconst IS_ANDROID = Platform.OS === 'android';\nconst ANDROID_LONG_TIMER_MESSAGE =\n  'Setting a timer for a long period of time, i.e. multiple minutes, is a ' +\n  'performance and correctness issue on Android as it keeps the timer ' +\n  'module awake, and timers can only be called when the app is in the foreground. ' +\n  'See https://github.com/facebook/react-native/issues/12981 for more info.';\n\n// Parallel arrays\nconst callbacks: Array<?Function> = [];\nconst types: Array<?JSTimerType> = [];\nconst timerIDs: Array<?number> = [];\nlet immediates: Array<number> = [];\nlet requestIdleCallbacks: Array<number> = [];\nconst requestIdleCallbackTimeouts: {[number]: number} = {};\nconst identifiers: Array<null | {methodName: string}> = [];\n\nlet GUID = 1;\nlet errors: ?Array<Error> = null;\n\nlet hasEmittedTimeDriftWarning = false;\n\n// Returns a free index if one is available, and the next consecutive index otherwise.\nfunction _getFreeIndex(): number {\n  let freeIndex = timerIDs.indexOf(null);\n  if (freeIndex === -1) {\n    freeIndex = timerIDs.length;\n  }\n  return freeIndex;\n}\n\nfunction _allocateCallback(func: Function, type: JSTimerType): number {\n  const id = GUID++;\n  const freeIndex = _getFreeIndex();\n  timerIDs[freeIndex] = id;\n  callbacks[freeIndex] = func;\n  types[freeIndex] = type;\n  if (__DEV__) {\n    const parseErrorStack = require('parseErrorStack');\n    const error: ExtendedError = new Error();\n    error.framesToPop = 1;\n    const stack = parseErrorStack(error);\n    if (stack) {\n      identifiers[freeIndex] = stack.shift();\n    }\n  }\n  return id;\n}\n\n/**\n * Calls the callback associated with the ID. Also unregister that callback\n * if it was a one time timer (setTimeout), and not unregister it if it was\n * recurring (setInterval).\n */\nfunction _callTimer(timerID: number, frameTime: number, didTimeout: ?boolean) {\n  /* $FlowFixMe(>=0.54.0 site=react_native_oss) This comment suppresses an\n   * error found when Flow v0.54 was deployed. To see the error delete this\n   * comment and run Flow. */\n  require('fbjs/lib/warning')(\n    timerID <= GUID,\n    'Tried to call timer with ID %s but no such timer exists.',\n    timerID,\n  );\n\n  // timerIndex of -1 means that no timer with that ID exists. There are\n  // two situations when this happens, when a garbage timer ID was given\n  // and when a previously existing timer was deleted before this callback\n  // fired. In both cases we want to ignore the timer id, but in the former\n  // case we warn as well.\n  const timerIndex = timerIDs.indexOf(timerID);\n  if (timerIndex === -1) {\n    return;\n  }\n\n  const type = types[timerIndex];\n  const callback = callbacks[timerIndex];\n  if (!callback || !type) {\n    console.error('No callback found for timerID ' + timerID);\n    return;\n  }\n\n  if (__DEV__) {\n    const identifier = identifiers[timerIndex] || {};\n    Systrace.beginEvent('Systrace.callTimer: ' + identifier.methodName);\n  }\n\n  // Clear the metadata\n  if (\n    type === 'setTimeout' ||\n    type === 'setImmediate' ||\n    type === 'requestAnimationFrame' ||\n    type === 'requestIdleCallback'\n  ) {\n    _clearIndex(timerIndex);\n  }\n\n  try {\n    if (\n      type === 'setTimeout' ||\n      type === 'setInterval' ||\n      type === 'setImmediate'\n    ) {\n      callback();\n    } else if (type === 'requestAnimationFrame') {\n      callback(performanceNow());\n    } else if (type === 'requestIdleCallback') {\n      callback({\n        timeRemaining: function() {\n          // TODO: Optimisation: allow running for longer than one frame if\n          // there are no pending JS calls on the bridge from native. This\n          // would require a way to check the bridge queue synchronously.\n          return Math.max(0, FRAME_DURATION - (performanceNow() - frameTime));\n        },\n        didTimeout: !!didTimeout,\n      });\n    } else {\n      console.error('Tried to call a callback with invalid type: ' + type);\n    }\n  } catch (e) {\n    // Don't rethrow so that we can run all timers.\n    if (!errors) {\n      errors = [e];\n    } else {\n      errors.push(e);\n    }\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n}\n\n/**\n * Performs a single pass over the enqueued immediates. Returns whether\n * more immediates are queued up (can be used as a condition a while loop).\n */\nfunction _callImmediatesPass() {\n  if (__DEV__) {\n    Systrace.beginEvent('callImmediatesPass()');\n  }\n\n  // The main reason to extract a single pass is so that we can track\n  // in the system trace\n  if (immediates.length > 0) {\n    const passImmediates = immediates.slice();\n    immediates = [];\n\n    // Use for loop rather than forEach as per @vjeux's advice\n    // https://github.com/facebook/react-native/commit/c8fd9f7588ad02d2293cac7224715f4af7b0f352#commitcomment-14570051\n    for (let i = 0; i < passImmediates.length; ++i) {\n      _callTimer(passImmediates[i], 0);\n    }\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n  return immediates.length > 0;\n}\n\nfunction _clearIndex(i: number) {\n  timerIDs[i] = null;\n  callbacks[i] = null;\n  types[i] = null;\n  identifiers[i] = null;\n}\n\nfunction _freeCallback(timerID: number) {\n  // timerIDs contains nulls after timers have been removed;\n  // ignore nulls upfront so indexOf doesn't find them\n  if (timerID == null) {\n    return;\n  }\n\n  const index = timerIDs.indexOf(timerID);\n  // See corresponding comment in `callTimers` for reasoning behind this\n  if (index !== -1) {\n    _clearIndex(index);\n    const type = types[index];\n    if (type !== 'setImmediate' && type !== 'requestIdleCallback') {\n      Timing.deleteTimer(timerID);\n    }\n  }\n}\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\nconst JSTimers = {\n  /**\n   * @param {function} func Callback to be invoked after `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setTimeout: function(func: Function, duration: number, ...args: any): number {\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(\n        ANDROID_LONG_TIMER_MESSAGE +\n          '\\n' +\n          '(Saw setTimeout with duration ' +\n          duration +\n          'ms)',\n      );\n    }\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setTimeout',\n    );\n    Timing.createTimer(id, duration || 0, Date.now(), /* recurring */ false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setInterval: function(\n    func: Function,\n    duration: number,\n    ...args: any\n  ): number {\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(\n        ANDROID_LONG_TIMER_MESSAGE +\n          '\\n' +\n          '(Saw setInterval with duration ' +\n          duration +\n          'ms)',\n      );\n    }\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setInterval',\n    );\n    Timing.createTimer(id, duration || 0, Date.now(), /* recurring */ true);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked before the end of the\n   * current JavaScript execution loop.\n   */\n  setImmediate: function(func: Function, ...args: any) {\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setImmediate',\n    );\n    immediates.push(id);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame.\n   */\n  requestAnimationFrame: function(func: Function) {\n    const id = _allocateCallback(func, 'requestAnimationFrame');\n    Timing.createTimer(id, 1, Date.now(), /* recurring */ false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame and provided\n   * with time remaining in frame.\n   * @param {?object} options\n   */\n  requestIdleCallback: function(func: Function, options: ?Object) {\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(true);\n    }\n\n    const timeout = options && options.timeout;\n    const id = _allocateCallback(\n      timeout != null\n        ? deadline => {\n            const timeoutId = requestIdleCallbackTimeouts[id];\n            if (timeoutId) {\n              JSTimers.clearTimeout(timeoutId);\n              delete requestIdleCallbackTimeouts[id];\n            }\n            return func(deadline);\n          }\n        : func,\n      'requestIdleCallback',\n    );\n    requestIdleCallbacks.push(id);\n\n    if (timeout != null) {\n      const timeoutId = JSTimers.setTimeout(() => {\n        const index = requestIdleCallbacks.indexOf(id);\n        if (index > -1) {\n          requestIdleCallbacks.splice(index, 1);\n          _callTimer(id, performanceNow(), true);\n        }\n        delete requestIdleCallbackTimeouts[id];\n        if (requestIdleCallbacks.length === 0) {\n          Timing.setSendIdleEvents(false);\n        }\n      }, timeout);\n      requestIdleCallbackTimeouts[id] = timeoutId;\n    }\n    return id;\n  },\n\n  cancelIdleCallback: function(timerID: number) {\n    _freeCallback(timerID);\n    const index = requestIdleCallbacks.indexOf(timerID);\n    if (index !== -1) {\n      requestIdleCallbacks.splice(index, 1);\n    }\n\n    const timeoutId = requestIdleCallbackTimeouts[timerID];\n    if (timeoutId) {\n      JSTimers.clearTimeout(timeoutId);\n      delete requestIdleCallbackTimeouts[timerID];\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(false);\n    }\n  },\n\n  clearTimeout: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  clearInterval: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  clearImmediate: function(timerID: number) {\n    _freeCallback(timerID);\n    const index = immediates.indexOf(timerID);\n    if (index !== -1) {\n      immediates.splice(index, 1);\n    }\n  },\n\n  cancelAnimationFrame: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  /**\n   * This is called from the native side. We are passed an array of timerIDs,\n   * and\n   */\n  callTimers: function(timersToCall: Array<number>) {\n    invariant(\n      timersToCall.length !== 0,\n      'Cannot call `callTimers` with an empty list of IDs.',\n    );\n\n    // $FlowFixMe: optionals do not allow assignment from null\n    errors = null;\n    for (let i = 0; i < timersToCall.length; i++) {\n      _callTimer(timersToCall[i], 0);\n    }\n\n    if (errors) {\n      const errorCount = errors.length;\n      if (errorCount > 1) {\n        // Throw all the other errors in a setTimeout, which will throw each\n        // error one at a time\n        for (let ii = 1; ii < errorCount; ii++) {\n          JSTimers.setTimeout(\n            (error => {\n              throw error;\n            }).bind(null, errors[ii]),\n            0,\n          );\n        }\n      }\n      throw errors[0];\n    }\n  },\n\n  callIdleCallbacks: function(frameTime: number) {\n    if (\n      FRAME_DURATION - (performanceNow() - frameTime) <\n      IDLE_CALLBACK_FRAME_DEADLINE\n    ) {\n      return;\n    }\n\n    // $FlowFixMe: optionals do not allow assignment from null\n    errors = null;\n    if (requestIdleCallbacks.length > 0) {\n      const passIdleCallbacks = requestIdleCallbacks.slice();\n      requestIdleCallbacks = [];\n\n      for (let i = 0; i < passIdleCallbacks.length; ++i) {\n        _callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(false);\n    }\n\n    if (errors) {\n      errors.forEach(error =>\n        JSTimers.setTimeout(() => {\n          throw error;\n        }, 0),\n      );\n    }\n  },\n\n  /**\n   * This is called after we execute any command we receive from native but\n   * before we hand control back to native.\n   */\n  callImmediates() {\n    errors = null;\n    while (_callImmediatesPass()) {}\n    if (errors) {\n      errors.forEach(error =>\n        JSTimers.setTimeout(() => {\n          throw error;\n        }, 0),\n      );\n    }\n  },\n\n  /**\n   * Called from native (in development) when environment times are out-of-sync.\n   */\n  emitTimeDriftWarning(warningMessage: string) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  },\n};\n\nlet ExportedJSTimers;\nif (!Timing) {\n  console.warn(\"Timing native module is not available, can't set timers.\");\n  // $FlowFixMe: we can assume timers are generally available\n  ExportedJSTimers = ({\n    callImmediates: JSTimers.callImmediates,\n    setImmediate: JSTimers.setImmediate,\n  }: typeof JSTimers);\n} else {\n  ExportedJSTimers = JSTimers;\n}\n\nBatchedBridge.setImmediatesCallback(\n  ExportedJSTimers.callImmediates.bind(ExportedJSTimers),\n);\n\nmodule.exports = ExportedJSTimers;\n"],"names":["require","d","invariant","Timing","BatchedBridge","_performanceNow","performanceNow","FRAME_DURATION","callbacks","types","timerIDs","immediates","requestIdleCallbacks","requestIdleCallbackTimeouts","identifiers","GUID","errors","hasEmittedTimeDriftWarning","_getFreeIndex","freeIndex","indexOf","length","_allocateCallback","func","type","id","_callTimer","timerID","frameTime","didTimeout","timerIndex","callback","_clearIndex","timeRemaining","Math","max","console","error","e","push","_callImmediatesPass","passImmediates","slice","i","_freeCallback","index","deleteTimer","ExportedJSTimers","JSTimers","setTimeout","duration","_len","arguments","args","Array","_key","apply","undefined","createTimer","Date","now","setInterval","_len2","_key2","setImmediate","_len3","_key3","requestAnimationFrame","requestIdleCallback","options","setSendIdleEvents","timeout","deadline","timeoutId","clearTimeout","splice","cancelIdleCallback","clearInterval","clearImmediate","cancelAnimationFrame","callTimers","timersToCall","errorCount","ii","bind","callIdleCallbacks","passIdleCallbacks","forEach","callImmediates","emitTimeDriftWarning","warningMessage","warn","setImmediatesCallback","module","exports"],"mappings":"4BASA,aAEiBA,EAAOC,EAAA,IACPD,EAAOC,EAAA,IADxB,IAGMC,EAAYF,EAAOC,EAAA,IAClBE,EAAUH,EAAOC,EAAA,IAAjBE,OACDC,EAAgBJ,EAAOC,EAAA,IAIzBI,EAAkB,KACtB,SAASC,IAOP,OANKD,IAIHA,EAAkBL,EAAOC,EAAA,KAEpBI,IAkBT,IAAME,EAAc,mBAYdC,KACAC,KACAC,KACFC,KACAC,KACEC,KACAC,KAEFC,EAAO,EACPC,EAAwB,KAExBC,GAA6B,EAGjC,SAASC,IACP,IAAIC,EAAYT,EAASU,QAAQ,MAIjC,OAHa,IAATD,IACFA,EAAYT,EAASW,QAEhBF,EAGT,SAASG,EAAkBC,EAAgBC,GACzC,IAAMC,EAAKV,IACLI,EAAYD,IAalB,OAZAR,EAASS,GAAaM,EACtBjB,EAAUW,GAAaI,EACvBd,EAAMU,GAAaK,EAUZC,EAQT,SAASC,EAAWC,EAAiBC,EAAmBC,GAItD7B,EAAOC,EAAA,GAAPD,CACE2B,GAAWZ,EACX,2DACAY,GAQF,IAAMG,EAAapB,EAASU,QAAQO,GACpC,IAAc,IAAVG,EAAJ,CAIA,IAAMN,EAAOf,EAAMqB,GACbC,EAAWvB,EAAUsB,GAC3B,GAAKC,GAAaP,EAAlB,CAYW,eAATA,GACS,iBAATA,GACS,0BAATA,GACS,wBAATA,GAEAQ,EAAYF,GAGd,IAEa,eAATN,GACS,gBAATA,GACS,iBAATA,EAEAO,IACkB,0BAATP,EACTO,EAASzB,KACS,wBAATkB,EACTO,GACEE,cAAe,WAIb,OAAOC,KAAKC,IAAI,EAAG5B,GAAkBD,IAAmBsB,KAE1DC,aAAcA,IAGhBO,QAAQC,MAAM,+CAAiDb,GAEjE,MAAOc,GAEFtB,EAGHA,EAAOuB,KAAKD,GAFZtB,GAAUsB,SA5CZF,QAAQC,MAAM,iCAAmCV,IA2DrD,SAASa,IAOP,GAAI7B,EAAWU,OAAS,EAAG,CACzB,IAAMoB,EAAiB9B,EAAW+B,QAClC/B,KAIA,IAAK,IAAIgC,EAAI,EAAGA,EAAIF,EAAepB,SAAUsB,EAC3CjB,EAAWe,EAAeE,GAAI,GAOlC,OAAOhC,EAAWU,OAAS,EAG7B,SAASW,EAAYW,GACnBjC,EAASiC,GAAK,KACdnC,EAAUmC,GAAK,KACflC,EAAMkC,GAAK,KACX7B,EAAY6B,GAAK,KAGnB,SAASC,EAAcjB,GAGrB,GAAe,MAAXA,EAAJ,CAIA,IAAMkB,EAAQnC,EAASU,QAAQO,GAE/B,IAAS,IAALkB,EAAc,CAChBb,EAAYa,GACZ,IAAMrB,EAAOf,EAAMoC,GACN,iBAATrB,GAAoC,wBAATA,GAC7BrB,EAAO2C,YAAYnB,KAUzB,IAsPIoB,EAtPEC,GAKJC,WAAY,SAAS1B,EAAgB2B,GAAwC,IAAA,IAAAC,EAAAC,UAAA/B,OAAnBgC,EAAmB,IAAAC,MAAAH,EAAA,EAAAA,EAAA,EAAA,GAAAI,EAAA,EAAAA,EAAAJ,EAAAI,IAAnBF,EAAmBE,EAAA,GAAAH,UAAAG,GAU3E,IAAM9B,EAAKH,EACT,WAAA,OAAMC,EAAKiC,WAAMC,EAAWJ,IAC5B,cAGF,OADAlD,EAAOuD,YAAYjC,EAAIyB,GAAY,EAAGS,KAAKC,OAAuB,GAC3DnC,GAOToC,YAAa,SACXtC,EACA2B,GAEQ,IAAA,IAAAY,EAAAV,UAAA/B,OADLgC,EACK,IAAAC,MAAAQ,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADLV,EACKU,EAAA,GAAAX,UAAAW,GAUR,IAAMtC,EAAKH,EACT,WAAA,OAAMC,EAAKiC,WAAMC,EAAWJ,IAC5B,eAGF,OADAlD,EAAOuD,YAAYjC,EAAIyB,GAAY,EAAGS,KAAKC,OAAuB,GAC3DnC,GAOTuC,aAAc,SAASzC,GAA8B,IAAA,IAAA0C,EAAAb,UAAA/B,OAAXgC,EAAW,IAAAC,MAAAW,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAXb,EAAWa,EAAA,GAAAd,UAAAc,GACnD,IAAMzC,EAAKH,EACT,WAAA,OAAMC,EAAKiC,WAAMC,EAAWJ,IAC5B,gBAGF,OADA1C,EAAW4B,KAAKd,GACTA,GAMT0C,sBAAuB,SAAS5C,GAC9B,IAAME,EAAKH,EAAkBC,EAAM,yBAEnC,OADApB,EAAOuD,YAAYjC,EAAI,EAAGkC,KAAKC,OAAuB,GAC/CnC,GAQT2C,oBAAqB,SAAS7C,EAAgB8C,GACR,IAAhCzD,EAAqBS,QACvBlB,EAAOmE,mBAAkB,GAG3B,IAAMC,EAAUF,GAAWA,EAAQE,QAC7B9C,EAAKH,EACE,MAAXiD,EACI,SAAAC,GACE,IAAMC,EAAY5D,EAA4BY,GAK9C,OAJIgD,IACFzB,EAAS0B,aAAaD,UACf5D,EAA4BY,IAE9BF,EAAKiD,IAEdjD,EACJ,uBAIF,GAFAX,EAAqB2B,KAAKd,GAEX,MAAX8C,EAAiB,CACnB,IAAME,EAAYzB,EAASC,WAAW,WACpC,IAAMJ,EAAQjC,EAAqBQ,QAAQK,GACvCoB,GAAK,IACPjC,EAAqB+D,OAAO9B,EAAO,GACnCnB,EAAWD,EAAInB,KAAkB,WAE5BO,EAA4BY,GACC,IAAhCb,EAAqBS,QACvBlB,EAAOmE,mBAAkB,IAE1BC,GACH1D,EAA4BY,GAAMgD,EAEpC,OAAOhD,GAGTmD,mBAAoB,SAASjD,GAC3BiB,EAAcjB,GACd,IAAMkB,EAAQjC,EAAqBQ,QAAQO,IAClC,IAALkB,GACFjC,EAAqB+D,OAAO9B,EAAO,GAGrC,IAAM4B,EAAY5D,EAA4Bc,GAC1C8C,IACFzB,EAAS0B,aAAaD,UACf5D,EAA4Bc,IAGD,IAAhCf,EAAqBS,QACvBlB,EAAOmE,mBAAkB,IAI7BI,aAAc,SAAS/C,GACrBiB,EAAcjB,IAGhBkD,cAAe,SAASlD,GACtBiB,EAAcjB,IAGhBmD,eAAgB,SAASnD,GACvBiB,EAAcjB,GACd,IAAMkB,EAAQlC,EAAWS,QAAQO,IACxB,IAALkB,GACFlC,EAAWgE,OAAO9B,EAAO,IAI7BkC,qBAAsB,SAASpD,GAC7BiB,EAAcjB,IAOhBqD,WAAY,SAASC,GACnB/E,EAC0B,IAAxB+E,EAAa5D,OACb,uDAIFL,EAAS,KACT,IAAK,IAAI2B,EAAI,EAAGA,EAAIsC,EAAa5D,OAAQsB,IACvCjB,EAAWuD,EAAatC,GAAI,GAG9B,GAAI3B,EAAQ,CACV,IAAMkE,EAAalE,EAAOK,OAC1B,GAAI6D,EAAa,EAGf,IAAK,IAAIC,EAAK,EAAGA,EAAKD,EAAYC,IAChCnC,EAASC,WACN,SAAAZ,GACC,MAAMA,GACL+C,KAAK,KAAMpE,EAAOmE,IACrB,GAIN,MAAMnE,EAAO,KAIjBqE,kBAAmB,SAASzD,GAC1B,KACErB,GAAkBD,IAAmBsB,GA5XN,GA2XjC,CASA,GADAZ,EAAS,KACLJ,EAAqBS,OAAS,EAAG,CACnC,IAAMiE,EAAoB1E,EAAqB8B,QAC/C9B,KAEA,IAAK,IAAI+B,EAAI,EAAGA,EAAI2C,EAAkBjE,SAAUsB,EAC9CjB,EAAW4D,EAAkB3C,GAAIf,GAID,IAAhChB,EAAqBS,QACvBlB,EAAOmE,mBAAkB,GAGvBtD,GACFA,EAAOuE,QAAQ,SAAAlD,GAAK,OAClBW,EAASC,WAAW,WAClB,MAAMZ,GACL,OASTmD,eA9Ne,WAgOb,IADAxE,EAAS,KACFwB,MACHxB,GACFA,EAAOuE,QAAQ,SAAAlD,GAAK,OAClBW,EAASC,WAAW,WAClB,MAAMZ,GACL,MAQToD,qBA7Oe,SA6OMC,GACfzE,IAGJA,GAA6B,EAC7BmB,QAAQuD,KAAKD,MAKZvF,EAQH4C,EAAmBC,GAPnBZ,QAAQuD,KAAK,4DAEb5C,GACEyC,eAAgBxC,EAASwC,eACzBxB,aAAchB,EAASgB,eAM3B5D,EAAcwF,sBACZ7C,EAAiByC,eAAeJ,KAAKrC,IAGvC8C,EAAOC,QAAU/C","file":"114.js"}