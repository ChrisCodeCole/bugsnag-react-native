{"version":3,"sources":["/Users/jamielynch/repos/bugsnag-react-native/examples/plain/node_modules/react-native/Libraries/Lists/FillRateHelper.js"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\n/* $FlowFixMe(>=0.54.0 site=react_native_oss) This comment suppresses an error\n * found when Flow v0.54 was deployed. To see the error delete this comment and\n * run Flow. */\nconst performanceNow = require('fbjs/lib/performanceNow');\n/* $FlowFixMe(>=0.54.0 site=react_native_oss) This comment suppresses an error\n * found when Flow v0.54 was deployed. To see the error delete this comment and\n * run Flow. */\nconst warning = require('fbjs/lib/warning');\n\nexport type FillRateInfo = Info;\n\nclass Info {\n  any_blank_count = 0;\n  any_blank_ms = 0;\n  any_blank_speed_sum = 0;\n  mostly_blank_count = 0;\n  mostly_blank_ms = 0;\n  pixels_blank = 0;\n  pixels_sampled = 0;\n  pixels_scrolled = 0;\n  total_time_spent = 0;\n  sample_count = 0;\n}\n\ntype FrameMetrics = {inLayout?: boolean, length: number, offset: number};\n\nconst DEBUG = false;\n\nlet _listeners: Array<(Info) => void> = [];\nlet _minSampleCount = 10;\nlet _sampleRate = DEBUG ? 1 : null;\n\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\nclass FillRateHelper {\n  _anyBlankStartTime = (null: ?number);\n  _enabled = false;\n  _getFrameMetrics: (index: number) => ?FrameMetrics;\n  _info = new Info();\n  _mostlyBlankStartTime = (null: ?number);\n  _samplesStartTime = (null: ?number);\n\n  static addListener(callback: FillRateInfo => void): {remove: () => void} {\n    warning(\n      _sampleRate !== null,\n      'Call `FillRateHelper.setSampleRate` before `addListener`.',\n    );\n    _listeners.push(callback);\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      },\n    };\n  }\n\n  static setSampleRate(sampleRate: number) {\n    _sampleRate = sampleRate;\n  }\n\n  static setMinSampleCount(minSampleCount: number) {\n    _minSampleCount = minSampleCount;\n  }\n\n  constructor(getFrameMetrics: (index: number) => ?FrameMetrics) {\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = performanceNow();\n    }\n  }\n\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n    const start = this._samplesStartTime; // const for flow\n    if (start == null) {\n      DEBUG &&\n        console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n      return;\n    }\n    const total_time_spent = performanceNow() - start;\n    const info: any = {\n      ...this._info,\n      total_time_spent,\n    };\n    if (DEBUG) {\n      const derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank:\n          this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min:\n          this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min:\n          this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent,\n      };\n      for (const key in derived) {\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n      console.debug('FillRateHelper deactivateAndFlush: ', {derived, info});\n    }\n    _listeners.forEach(listener => listener(info));\n    this._resetData();\n  }\n\n  computeBlankness(\n    props: {\n      data: Array<any>,\n      getItemCount: (data: Array<any>) => number,\n      initialNumToRender: number,\n    },\n    state: {\n      first: number,\n      last: number,\n    },\n    scrollMetrics: {\n      dOffset: number,\n      offset: number,\n      velocity: number,\n      visibleLength: number,\n    },\n  ): number {\n    if (\n      !this._enabled ||\n      props.getItemCount(props.data) === 0 ||\n      this._samplesStartTime == null\n    ) {\n      return 0;\n    }\n    const {dOffset, offset, velocity, visibleLength} = scrollMetrics;\n\n    // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    const scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n    const now = performanceNow();\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n    this._anyBlankStartTime = null;\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n    this._mostlyBlankStartTime = null;\n\n    let blankTop = 0;\n    let first = state.first;\n    let firstFrame = this._getFrameMetrics(first);\n    while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\n      firstFrame = this._getFrameMetrics(first);\n      first++;\n    }\n    // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(\n        visibleLength,\n        Math.max(0, firstFrame.offset - offset),\n      );\n    }\n    let blankBottom = 0;\n    let last = state.last;\n    let lastFrame = this._getFrameMetrics(last);\n    while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\n      lastFrame = this._getFrameMetrics(last);\n      last--;\n    }\n    // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      const bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(\n        visibleLength,\n        Math.max(0, offset + visibleLength - bottomEdge),\n      );\n    }\n    const pixels_blank = Math.round(blankTop + blankBottom);\n    const blankness = pixels_blank / visibleLength;\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n    return blankness;\n  }\n\n  enabled(): boolean {\n    return this._enabled;\n  }\n\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n}\n\nmodule.exports = FillRateHelper;\n"],"names":["performanceNow","require","d","warning","Info","any_blank_count","any_blank_ms","any_blank_speed_sum","mostly_blank_count","mostly_blank_ms","pixels_blank","pixels_sampled","pixels_scrolled","total_time_spent","sample_count","_listeners","_minSampleCount","_sampleRate","FillRateHelper","getFrameMetrics","_classCallCheck","this","_anyBlankStartTime","_enabled","_info","_mostlyBlankStartTime","_samplesStartTime","_getFrameMetrics","Math","random","_resetData","callback","push","remove","filter","listener","sampleRate","minSampleCount","start","info","_objectSpread","forEach","props","state","scrollMetrics","getItemCount","data","dOffset","offset","velocity","visibleLength","round","abs","scrollSpeed","now","blankTop","first","firstFrame","last","inLayout","min","max","blankBottom","lastFrame","bottomEdge","length","blankness","deactivateAndFlush","module","exports"],"mappings":"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","file":"253.js"}