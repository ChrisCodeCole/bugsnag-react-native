{"version":3,"sources":["/Users/jamielynch/repos/bugsnag-react-native/examples/plain/node_modules/react-native/Libraries/Lists/ListView/ListView.js"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n'use strict';\n\nconst InternalListViewType = require('InternalListViewType');\nconst ListViewDataSource = require('ListViewDataSource');\nconst Platform = require('Platform');\nconst React = require('React');\nconst ReactNative = require('ReactNative');\nconst RCTScrollViewManager = require('NativeModules').ScrollViewManager;\nconst ScrollView = require('ScrollView');\nconst ScrollResponder = require('ScrollResponder');\nconst StaticRenderer = require('StaticRenderer');\nconst View = require('View');\nconst cloneReferencedElement = require('react-clone-referenced-element');\nconst createReactClass = require('create-react-class');\nconst isEmpty = require('isEmpty');\nconst merge = require('merge');\n\nimport type {Props as ScrollViewProps} from 'ScrollView';\n\nconst DEFAULT_PAGE_SIZE = 1;\nconst DEFAULT_INITIAL_ROWS = 10;\nconst DEFAULT_SCROLL_RENDER_AHEAD = 1000;\nconst DEFAULT_END_REACHED_THRESHOLD = 1000;\nconst DEFAULT_SCROLL_CALLBACK_THROTTLE = 50;\n\ntype Props = $ReadOnly<{|\n  ...ScrollViewProps,\n\n  /**\n   * An instance of [ListView.DataSource](docs/listviewdatasource.html) to use\n   */\n  dataSource: ListViewDataSource,\n  /**\n   * (sectionID, rowID, adjacentRowHighlighted) => renderable\n   *\n   * If provided, a renderable component to be rendered as the separator\n   * below each row but not the last row if there is a section header below.\n   * Take a sectionID and rowID of the row above and whether its adjacent row\n   * is highlighted.\n   */\n  renderSeparator?: ?Function,\n  /**\n   * (rowData, sectionID, rowID, highlightRow) => renderable\n   *\n   * Takes a data entry from the data source and its ids and should return\n   * a renderable component to be rendered as the row. By default the data\n   * is exactly what was put into the data source, but it's also possible to\n   * provide custom extractors. ListView can be notified when a row is\n   * being highlighted by calling `highlightRow(sectionID, rowID)`. This\n   * sets a boolean value of adjacentRowHighlighted in renderSeparator, allowing you\n   * to control the separators above and below the highlighted row. The highlighted\n   * state of a row can be reset by calling highlightRow(null).\n   */\n  renderRow: Function,\n  /**\n   * How many rows to render on initial component mount. Use this to make\n   * it so that the first screen worth of data appears at one time instead of\n   * over the course of multiple frames.\n   */\n  initialListSize?: ?number,\n  /**\n   * Called when all rows have been rendered and the list has been scrolled\n   * to within onEndReachedThreshold of the bottom. The native scroll\n   * event is provided.\n   */\n  onEndReached?: ?Function,\n  /**\n   * Threshold in pixels (virtual, not physical) for calling onEndReached.\n   */\n  onEndReachedThreshold?: ?number,\n  /**\n   * Number of rows to render per event loop. Note: if your 'rows' are actually\n   * cells, i.e. they don't span the full width of your view (as in the\n   * ListViewGridLayoutExample), you should set the pageSize to be a multiple\n   * of the number of cells per row, otherwise you're likely to see gaps at\n   * the edge of the ListView as new pages are loaded.\n   */\n  pageSize?: ?number,\n  /**\n   * () => renderable\n   *\n   * The header and footer are always rendered (if these props are provided)\n   * on every render pass. If they are expensive to re-render, wrap them\n   * in StaticContainer or other mechanism as appropriate. Footer is always\n   * at the bottom of the list, and header at the top, on every render pass.\n   * In a horizontal ListView, the header is rendered on the left and the\n   * footer on the right.\n   */\n  renderFooter?: ?Function,\n  renderHeader?: ?Function,\n  /**\n   * (sectionData, sectionID) => renderable\n   *\n   * If provided, a header is rendered for this section.\n   */\n  renderSectionHeader?: ?Function,\n  /**\n   * (props) => renderable\n   *\n   * A function that returns the scrollable component in which the list rows\n   * are rendered. Defaults to returning a ScrollView with the given props.\n   */\n  renderScrollComponent?: ?Function,\n  /**\n   * How early to start rendering rows before they come on screen, in\n   * pixels.\n   */\n  scrollRenderAheadDistance?: ?number,\n  /**\n   * (visibleRows, changedRows) => void\n   *\n   * Called when the set of visible rows changes. `visibleRows` maps\n   * { sectionID: { rowID: true }} for all the visible rows, and\n   * `changedRows` maps { sectionID: { rowID: true | false }} for the rows\n   * that have changed their visibility, with true indicating visible, and\n   * false indicating the view has moved out of view.\n   */\n  onChangeVisibleRows?: ?Function,\n  /**\n   * A performance optimization for improving scroll perf of\n   * large lists, used in conjunction with overflow: 'hidden' on the row\n   * containers. This is enabled by default.\n   */\n  removeClippedSubviews?: ?boolean,\n  /**\n   * Makes the sections headers sticky. The sticky behavior means that it\n   * will scroll with the content at the top of the section until it reaches\n   * the top of the screen, at which point it will stick to the top until it\n   * is pushed off the screen by the next section header. This property is\n   * not supported in conjunction with `horizontal={true}`. Only enabled by\n   * default on iOS because of typical platform standards.\n   */\n  stickySectionHeadersEnabled?: ?boolean,\n  /**\n   * An array of child indices determining which children get docked to the\n   * top of the screen when scrolling. For example, passing\n   * `stickyHeaderIndices={[0]}` will cause the first child to be fixed to the\n   * top of the scroll view. This property is not supported in conjunction\n   * with `horizontal={true}`.\n   */\n  stickyHeaderIndices?: ?$ReadOnlyArray<number>,\n  /**\n   * Flag indicating whether empty section headers should be rendered. In the future release\n   * empty section headers will be rendered by default, and the flag will be deprecated.\n   * If empty sections are not desired to be rendered their indices should be excluded from sectionID object.\n   */\n  enableEmptySections?: ?boolean,\n|}>;\n\n/**\n * DEPRECATED - use one of the new list components, such as [`FlatList`](docs/flatlist.html)\n * or [`SectionList`](docs/sectionlist.html) for bounded memory use, fewer bugs,\n * better performance, an easier to use API, and more features. Check out this\n * [blog post](https://facebook.github.io/react-native/blog/2017/03/13/better-list-views.html)\n * for more details.\n *\n * ListView - A core component designed for efficient display of vertically\n * scrolling lists of changing data. The minimal API is to create a\n * [`ListView.DataSource`](docs/listviewdatasource.html), populate it with a simple\n * array of data blobs, and instantiate a `ListView` component with that data\n * source and a `renderRow` callback which takes a blob from the data array and\n * returns a renderable component.\n *\n * Minimal example:\n *\n * ```\n * class MyComponent extends Component {\n *   constructor() {\n *     super();\n *     const ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2});\n *     this.state = {\n *       dataSource: ds.cloneWithRows(['row 1', 'row 2']),\n *     };\n *   }\n *\n *   render() {\n *     return (\n *       <ListView\n *         dataSource={this.state.dataSource}\n *         renderRow={(rowData) => <Text>{rowData}</Text>}\n *       />\n *     );\n *   }\n * }\n * ```\n *\n * ListView also supports more advanced features, including sections with sticky\n * section headers, header and footer support, callbacks on reaching the end of\n * the available data (`onEndReached`) and on the set of rows that are visible\n * in the device viewport change (`onChangeVisibleRows`), and several\n * performance optimizations.\n *\n * There are a few performance operations designed to make ListView scroll\n * smoothly while dynamically loading potentially very large (or conceptually\n * infinite) data sets:\n *\n *  * Only re-render changed rows - the rowHasChanged function provided to the\n *    data source tells the ListView if it needs to re-render a row because the\n *    source data has changed - see ListViewDataSource for more details.\n *\n *  * Rate-limited row rendering - By default, only one row is rendered per\n *    event-loop (customizable with the `pageSize` prop). This breaks up the\n *    work into smaller chunks to reduce the chance of dropping frames while\n *    rendering rows.\n */\n\nconst ListView = createReactClass({\n  displayName: 'ListView',\n  _rafIds: ([]: Array<AnimationFrameID>),\n  _childFrames: ([]: Array<Object>),\n  _sentEndForContentLength: (null: ?number),\n  _scrollComponent: (null: ?React.ElementRef<typeof ScrollView>),\n  _prevRenderedRowsCount: 0,\n  _visibleRows: ({}: Object),\n  scrollProperties: ({}: Object),\n\n  mixins: [ScrollResponder.Mixin],\n\n  statics: {\n    DataSource: ListViewDataSource,\n  },\n\n  /**\n   * Exports some data, e.g. for perf investigations or analytics.\n   */\n  getMetrics: function() {\n    return {\n      contentLength: this.scrollProperties.contentLength,\n      totalRows: this.props.enableEmptySections\n        ? this.props.dataSource.getRowAndSectionCount()\n        : this.props.dataSource.getRowCount(),\n      renderedRows: this.state.curRenderedRowsCount,\n      visibleRows: Object.keys(this._visibleRows).length,\n    };\n  },\n\n  /**\n   * Provides a handle to the underlying scroll responder.\n   * Note that `this._scrollComponent` might not be a `ScrollView`, so we\n   * need to check that it responds to `getScrollResponder` before calling it.\n   */\n  getScrollResponder: function() {\n    if (this._scrollComponent && this._scrollComponent.getScrollResponder) {\n      return this._scrollComponent.getScrollResponder();\n    }\n  },\n\n  getScrollableNode: function() {\n    if (this._scrollComponent && this._scrollComponent.getScrollableNode) {\n      return this._scrollComponent.getScrollableNode();\n    } else {\n      return ReactNative.findNodeHandle(this._scrollComponent);\n    }\n  },\n\n  /**\n   * Scrolls to a given x, y offset, either immediately or with a smooth animation.\n   *\n   * See `ScrollView#scrollTo`.\n   */\n  scrollTo: function(...args: any) {\n    if (this._scrollComponent && this._scrollComponent.scrollTo) {\n      this._scrollComponent.scrollTo(...args);\n    }\n  },\n\n  /**\n   * If this is a vertical ListView scrolls to the bottom.\n   * If this is a horizontal ListView scrolls to the right.\n   *\n   * Use `scrollToEnd({animated: true})` for smooth animated scrolling,\n   * `scrollToEnd({animated: false})` for immediate scrolling.\n   * If no options are passed, `animated` defaults to true.\n   *\n   * See `ScrollView#scrollToEnd`.\n   */\n  scrollToEnd: function(options?: ?{animated?: boolean}) {\n    if (this._scrollComponent) {\n      if (this._scrollComponent.scrollToEnd) {\n        this._scrollComponent.scrollToEnd(options);\n      } else {\n        console.warn(\n          'The scroll component used by the ListView does not support ' +\n            'scrollToEnd. Check the renderScrollComponent prop of your ListView.',\n        );\n      }\n    }\n  },\n\n  /**\n   * Displays the scroll indicators momentarily.\n   *\n   * @platform ios\n   */\n  flashScrollIndicators: function() {\n    if (this._scrollComponent && this._scrollComponent.flashScrollIndicators) {\n      this._scrollComponent.flashScrollIndicators();\n    }\n  },\n\n  setNativeProps: function(props: Object) {\n    if (this._scrollComponent) {\n      this._scrollComponent.setNativeProps(props);\n    }\n  },\n\n  /**\n   * React life cycle hooks.\n   */\n\n  getDefaultProps: function() {\n    return {\n      initialListSize: DEFAULT_INITIAL_ROWS,\n      pageSize: DEFAULT_PAGE_SIZE,\n      renderScrollComponent: props => <ScrollView {...props} />,\n      scrollRenderAheadDistance: DEFAULT_SCROLL_RENDER_AHEAD,\n      onEndReachedThreshold: DEFAULT_END_REACHED_THRESHOLD,\n      stickySectionHeadersEnabled: Platform.OS === 'ios',\n      stickyHeaderIndices: [],\n    };\n  },\n\n  getInitialState: function() {\n    return {\n      curRenderedRowsCount: this.props.initialListSize,\n      highlightedRow: ({}: Object),\n    };\n  },\n\n  getInnerViewNode: function() {\n    return this._scrollComponent && this._scrollComponent.getInnerViewNode();\n  },\n\n  UNSAFE_componentWillMount: function() {\n    // this data should never trigger a render pass, so don't put in state\n    this.scrollProperties = {\n      visibleLength: null,\n      contentLength: null,\n      offset: 0,\n    };\n\n    this._rafIds = [];\n    this._childFrames = [];\n    this._visibleRows = {};\n    this._prevRenderedRowsCount = 0;\n    this._sentEndForContentLength = null;\n  },\n\n  componentWillUnmount: function() {\n    this._rafIds.forEach(cancelAnimationFrame);\n    this._rafIds = [];\n  },\n\n  componentDidMount: function() {\n    // do this in animation frame until componentDidMount actually runs after\n    // the component is laid out\n    this._requestAnimationFrame(() => {\n      this._measureAndUpdateScrollProps();\n    });\n  },\n\n  UNSAFE_componentWillReceiveProps: function(nextProps: Object) {\n    if (\n      this.props.dataSource !== nextProps.dataSource ||\n      this.props.initialListSize !== nextProps.initialListSize\n    ) {\n      this.setState(\n        (state, props) => {\n          this._prevRenderedRowsCount = 0;\n          return {\n            curRenderedRowsCount: Math.min(\n              Math.max(state.curRenderedRowsCount, props.initialListSize),\n              props.enableEmptySections\n                ? props.dataSource.getRowAndSectionCount()\n                : props.dataSource.getRowCount(),\n            ),\n          };\n        },\n        () => this._renderMoreRowsIfNeeded(),\n      );\n    }\n  },\n\n  componentDidUpdate: function() {\n    this._requestAnimationFrame(() => {\n      this._measureAndUpdateScrollProps();\n    });\n  },\n\n  _onRowHighlighted: function(sectionID: string, rowID: string) {\n    this.setState({highlightedRow: {sectionID, rowID}});\n  },\n\n  render: function() {\n    const bodyComponents = [];\n\n    const dataSource = this.props.dataSource;\n    const allRowIDs = dataSource.rowIdentities;\n    let rowCount = 0;\n    const stickySectionHeaderIndices = [];\n\n    const {renderSectionHeader} = this.props;\n\n    const header = this.props.renderHeader && this.props.renderHeader();\n    const footer = this.props.renderFooter && this.props.renderFooter();\n    let totalIndex = header ? 1 : 0;\n\n    for (let sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {\n      const sectionID = dataSource.sectionIdentities[sectionIdx];\n      const rowIDs = allRowIDs[sectionIdx];\n      if (rowIDs.length === 0) {\n        if (this.props.enableEmptySections === undefined) {\n          const warning = require('fbjs/lib/warning');\n          warning(\n            false,\n            'In next release empty section headers will be rendered.' +\n              \" In this release you can use 'enableEmptySections' flag to render empty section headers.\",\n          );\n          continue;\n        } else {\n          const invariant = require('fbjs/lib/invariant');\n          invariant(\n            this.props.enableEmptySections,\n            \"In next release 'enableEmptySections' flag will be deprecated, empty section headers will always be rendered.\" +\n              ' If empty section headers are not desirable their indices should be excluded from sectionIDs object.' +\n              \" In this release 'enableEmptySections' may only have value 'true' to allow empty section headers rendering.\",\n          );\n        }\n      }\n\n      if (renderSectionHeader) {\n        const element = renderSectionHeader(\n          dataSource.getSectionHeaderData(sectionIdx),\n          sectionID,\n        );\n        if (element) {\n          bodyComponents.push(\n            React.cloneElement(element, {key: 's_' + sectionID}),\n          );\n          if (this.props.stickySectionHeadersEnabled) {\n            stickySectionHeaderIndices.push(totalIndex);\n          }\n          totalIndex++;\n        }\n      }\n\n      for (let rowIdx = 0; rowIdx < rowIDs.length; rowIdx++) {\n        const rowID = rowIDs[rowIdx];\n        const comboID = sectionID + '_' + rowID;\n        const shouldUpdateRow =\n          rowCount >= this._prevRenderedRowsCount &&\n          dataSource.rowShouldUpdate(sectionIdx, rowIdx);\n        const row = (\n          <StaticRenderer\n            key={'r_' + comboID}\n            shouldUpdate={!!shouldUpdateRow}\n            render={this.props.renderRow.bind(\n              null,\n              dataSource.getRowData(sectionIdx, rowIdx),\n              sectionID,\n              rowID,\n              this._onRowHighlighted,\n            )}\n          />\n        );\n        bodyComponents.push(row);\n        totalIndex++;\n\n        if (\n          this.props.renderSeparator &&\n          (rowIdx !== rowIDs.length - 1 || sectionIdx === allRowIDs.length - 1)\n        ) {\n          const adjacentRowHighlighted =\n            this.state.highlightedRow.sectionID === sectionID &&\n            (this.state.highlightedRow.rowID === rowID ||\n              this.state.highlightedRow.rowID === rowIDs[rowIdx + 1]);\n          const separator = this.props.renderSeparator(\n            sectionID,\n            rowID,\n            adjacentRowHighlighted,\n          );\n          if (separator) {\n            bodyComponents.push(<View key={'s_' + comboID}>{separator}</View>);\n            totalIndex++;\n          }\n        }\n        if (++rowCount === this.state.curRenderedRowsCount) {\n          break;\n        }\n      }\n      if (rowCount >= this.state.curRenderedRowsCount) {\n        break;\n      }\n    }\n\n    const {renderScrollComponent, ...props} = this.props;\n    if (!props.scrollEventThrottle) {\n      props.scrollEventThrottle = DEFAULT_SCROLL_CALLBACK_THROTTLE;\n    }\n    if (props.removeClippedSubviews === undefined) {\n      props.removeClippedSubviews = true;\n    }\n    Object.assign(props, {\n      onScroll: this._onScroll,\n      stickyHeaderIndices: this.props.stickyHeaderIndices.concat(\n        stickySectionHeaderIndices,\n      ),\n\n      // Do not pass these events downstream to ScrollView since they will be\n      // registered in ListView's own ScrollResponder.Mixin\n      onKeyboardWillShow: undefined,\n      onKeyboardWillHide: undefined,\n      onKeyboardDidShow: undefined,\n      onKeyboardDidHide: undefined,\n    });\n\n    return cloneReferencedElement(\n      renderScrollComponent(props),\n      {\n        ref: this._setScrollComponentRef,\n        onContentSizeChange: this._onContentSizeChange,\n        onLayout: this._onLayout,\n        DEPRECATED_sendUpdatedChildFrames:\n          typeof props.onChangeVisibleRows !== undefined,\n      },\n      header,\n      bodyComponents,\n      footer,\n    );\n  },\n\n  /**\n   * Private methods\n   */\n\n  _requestAnimationFrame: function(fn: () => void): void {\n    const rafId = requestAnimationFrame(() => {\n      this._rafIds = this._rafIds.filter(id => id !== rafId);\n      fn();\n    });\n    this._rafIds.push(rafId);\n  },\n\n  _measureAndUpdateScrollProps: function() {\n    const scrollComponent = this.getScrollResponder();\n    if (!scrollComponent || !scrollComponent.getInnerViewNode) {\n      return;\n    }\n\n    // RCTScrollViewManager.calculateChildFrames is not available on\n    // every platform\n    RCTScrollViewManager &&\n      RCTScrollViewManager.calculateChildFrames &&\n      RCTScrollViewManager.calculateChildFrames(\n        ReactNative.findNodeHandle(scrollComponent),\n        this._updateVisibleRows,\n      );\n  },\n\n  _setScrollComponentRef: function(scrollComponent) {\n    this._scrollComponent = scrollComponent;\n  },\n\n  _onContentSizeChange: function(width: number, height: number) {\n    const contentLength = !this.props.horizontal ? height : width;\n    if (contentLength !== this.scrollProperties.contentLength) {\n      this.scrollProperties.contentLength = contentLength;\n      this._updateVisibleRows();\n      this._renderMoreRowsIfNeeded();\n    }\n    this.props.onContentSizeChange &&\n      this.props.onContentSizeChange(width, height);\n  },\n\n  _onLayout: function(event: Object) {\n    const {width, height} = event.nativeEvent.layout;\n    const visibleLength = !this.props.horizontal ? height : width;\n    if (visibleLength !== this.scrollProperties.visibleLength) {\n      this.scrollProperties.visibleLength = visibleLength;\n      this._updateVisibleRows();\n      this._renderMoreRowsIfNeeded();\n    }\n    this.props.onLayout && this.props.onLayout(event);\n  },\n\n  _maybeCallOnEndReached: function(event?: Object) {\n    if (\n      this.props.onEndReached &&\n      this.scrollProperties.contentLength !== this._sentEndForContentLength &&\n      this._getDistanceFromEnd(this.scrollProperties) <\n        this.props.onEndReachedThreshold &&\n      this.state.curRenderedRowsCount ===\n        (this.props.enableEmptySections\n          ? this.props.dataSource.getRowAndSectionCount()\n          : this.props.dataSource.getRowCount())\n    ) {\n      this._sentEndForContentLength = this.scrollProperties.contentLength;\n      this.props.onEndReached(event);\n      return true;\n    }\n    return false;\n  },\n\n  _renderMoreRowsIfNeeded: function() {\n    if (\n      this.scrollProperties.contentLength === null ||\n      this.scrollProperties.visibleLength === null ||\n      this.state.curRenderedRowsCount ===\n        (this.props.enableEmptySections\n          ? this.props.dataSource.getRowAndSectionCount()\n          : this.props.dataSource.getRowCount())\n    ) {\n      this._maybeCallOnEndReached();\n      return;\n    }\n\n    const distanceFromEnd = this._getDistanceFromEnd(this.scrollProperties);\n    if (distanceFromEnd < this.props.scrollRenderAheadDistance) {\n      this._pageInNewRows();\n    }\n  },\n\n  _pageInNewRows: function() {\n    this.setState(\n      (state, props) => {\n        const rowsToRender = Math.min(\n          state.curRenderedRowsCount + props.pageSize,\n          props.enableEmptySections\n            ? props.dataSource.getRowAndSectionCount()\n            : props.dataSource.getRowCount(),\n        );\n        this._prevRenderedRowsCount = state.curRenderedRowsCount;\n        return {\n          curRenderedRowsCount: rowsToRender,\n        };\n      },\n      () => {\n        this._measureAndUpdateScrollProps();\n        this._prevRenderedRowsCount = this.state.curRenderedRowsCount;\n      },\n    );\n  },\n\n  _getDistanceFromEnd: function(scrollProperties: Object) {\n    return (\n      scrollProperties.contentLength -\n      scrollProperties.visibleLength -\n      scrollProperties.offset\n    );\n  },\n\n  _updateVisibleRows: function(updatedFrames?: Array<Object>) {\n    if (!this.props.onChangeVisibleRows) {\n      return; // No need to compute visible rows if there is no callback\n    }\n    if (updatedFrames) {\n      updatedFrames.forEach(newFrame => {\n        this._childFrames[newFrame.index] = merge(newFrame);\n      });\n    }\n    const isVertical = !this.props.horizontal;\n    const dataSource = this.props.dataSource;\n    const visibleMin = this.scrollProperties.offset;\n    const visibleMax = visibleMin + this.scrollProperties.visibleLength;\n    const allRowIDs = dataSource.rowIdentities;\n\n    const header = this.props.renderHeader && this.props.renderHeader();\n    let totalIndex = header ? 1 : 0;\n    let visibilityChanged = false;\n    const changedRows = {};\n    for (let sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {\n      const rowIDs = allRowIDs[sectionIdx];\n      if (rowIDs.length === 0) {\n        continue;\n      }\n      const sectionID = dataSource.sectionIdentities[sectionIdx];\n      if (this.props.renderSectionHeader) {\n        totalIndex++;\n      }\n      let visibleSection = this._visibleRows[sectionID];\n      if (!visibleSection) {\n        visibleSection = {};\n      }\n      for (let rowIdx = 0; rowIdx < rowIDs.length; rowIdx++) {\n        const rowID = rowIDs[rowIdx];\n        const frame = this._childFrames[totalIndex];\n        totalIndex++;\n        if (\n          this.props.renderSeparator &&\n          (rowIdx !== rowIDs.length - 1 || sectionIdx === allRowIDs.length - 1)\n        ) {\n          totalIndex++;\n        }\n        if (!frame) {\n          break;\n        }\n        const rowVisible = visibleSection[rowID];\n        const min = isVertical ? frame.y : frame.x;\n        const max = min + (isVertical ? frame.height : frame.width);\n        if ((!min && !max) || min === max) {\n          break;\n        }\n        if (min > visibleMax || max < visibleMin) {\n          if (rowVisible) {\n            visibilityChanged = true;\n            delete visibleSection[rowID];\n            if (!changedRows[sectionID]) {\n              changedRows[sectionID] = {};\n            }\n            changedRows[sectionID][rowID] = false;\n          }\n        } else if (!rowVisible) {\n          visibilityChanged = true;\n          visibleSection[rowID] = true;\n          if (!changedRows[sectionID]) {\n            changedRows[sectionID] = {};\n          }\n          changedRows[sectionID][rowID] = true;\n        }\n      }\n      if (!isEmpty(visibleSection)) {\n        this._visibleRows[sectionID] = visibleSection;\n      } else if (this._visibleRows[sectionID]) {\n        delete this._visibleRows[sectionID];\n      }\n    }\n    visibilityChanged &&\n      this.props.onChangeVisibleRows(this._visibleRows, changedRows);\n  },\n\n  _onScroll: function(e: Object) {\n    const isVertical = !this.props.horizontal;\n    this.scrollProperties.visibleLength =\n      e.nativeEvent.layoutMeasurement[isVertical ? 'height' : 'width'];\n    this.scrollProperties.contentLength =\n      e.nativeEvent.contentSize[isVertical ? 'height' : 'width'];\n    this.scrollProperties.offset =\n      e.nativeEvent.contentOffset[isVertical ? 'y' : 'x'];\n    this._updateVisibleRows(e.nativeEvent.updatedChildFrames);\n    if (!this._maybeCallOnEndReached(e)) {\n      this._renderMoreRowsIfNeeded();\n    }\n\n    if (\n      this.props.onEndReached &&\n      this._getDistanceFromEnd(this.scrollProperties) >\n        this.props.onEndReachedThreshold\n    ) {\n      // Scrolled out of the end zone, so it should be able to trigger again.\n      this._sentEndForContentLength = null;\n    }\n\n    this.props.onScroll && this.props.onScroll(e);\n  },\n});\n\nmodule.exports = ((ListView: any): Class<InternalListViewType<Props>>);\n"],"names":["ListViewDataSource","require","d","React","ReactNative","RCTScrollViewManager","ScrollViewManager","ScrollView","ScrollResponder","StaticRenderer","View","cloneReferencedElement","createReactClass","isEmpty","merge","ListView","displayName","_rafIds","_childFrames","_sentEndForContentLength","_scrollComponent","_prevRenderedRowsCount","_visibleRows","scrollProperties","mixins","Mixin","statics","DataSource","getMetrics","contentLength","this","totalRows","props","enableEmptySections","dataSource","getRowAndSectionCount","getRowCount","renderedRows","state","curRenderedRowsCount","visibleRows","Object","keys","length","getScrollResponder","getScrollableNode","findNodeHandle","scrollTo","_this$_scrollComponen","apply","arguments","scrollToEnd","options","console","warn","flashScrollIndicators","setNativeProps","getDefaultProps","initialListSize","pageSize","renderScrollComponent","createElement","scrollRenderAheadDistance","onEndReachedThreshold","stickySectionHeadersEnabled","stickyHeaderIndices","getInitialState","highlightedRow","getInnerViewNode","UNSAFE_componentWillMount","visibleLength","offset","componentWillUnmount","forEach","cancelAnimationFrame","componentDidMount","_this","_requestAnimationFrame","_measureAndUpdateScrollProps","UNSAFE_componentWillReceiveProps","nextProps","_this2","setState","Math","min","max","_renderMoreRowsIfNeeded","componentDidUpdate","_this3","_onRowHighlighted","sectionID","rowID","render","bodyComponents","allRowIDs","rowIdentities","rowCount","stickySectionHeaderIndices","renderSectionHeader","header","renderHeader","footer","renderFooter","totalIndex","sectionIdx","sectionIdentities","rowIDs","undefined","warning","invariant","element","getSectionHeaderData","push","cloneElement","key","rowIdx","comboID","shouldUpdateRow","rowShouldUpdate","row","shouldUpdate","renderRow","bind","getRowData","renderSeparator","adjacentRowHighlighted","separator","_this$props","_objectWithoutProperties","scrollEventThrottle","removeClippedSubviews","_extends","onScroll","_onScroll","concat","onKeyboardWillShow","onKeyboardWillHide","onKeyboardDidShow","onKeyboardDidHide","ref","_setScrollComponentRef","onContentSizeChange","_onContentSizeChange","onLayout","_onLayout","DEPRECATED_sendUpdatedChildFrames","onChangeVisibleRows","fn","_this4","rafId","requestAnimationFrame","filter","id","scrollComponent","calculateChildFrames","_updateVisibleRows","width","height","horizontal","event","_event$nativeEvent$la","nativeEvent","layout","_maybeCallOnEndReached","onEndReached","_getDistanceFromEnd","_pageInNewRows","_this5","rowsToRender","updatedFrames","_this6","newFrame","index","isVertical","visibleMin","visibleMax","visibilityChanged","changedRows","visibleSection","frame","rowVisible","y","x","e","layoutMeasurement","contentSize","contentOffset","updatedChildFrames","module","exports"],"mappings":"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","file":"234.js"}