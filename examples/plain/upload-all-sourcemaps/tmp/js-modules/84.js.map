{"version":3,"sources":["/Users/jamielynch/repos/bugsnag-react-native/examples/plain/node_modules/react-native/Libraries/StyleSheet/processTransform.js"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst MatrixMath = require('MatrixMath');\nconst Platform = require('Platform');\n\nconst invariant = require('fbjs/lib/invariant');\nconst stringifySafe = require('stringifySafe');\n\n/**\n * Generate a transform matrix based on the provided transforms, and use that\n * within the style object instead.\n *\n * This allows us to provide an API that is similar to CSS, where transforms may\n * be applied in an arbitrary order, and yet have a universal, singular\n * interface to native code.\n */\nfunction processTransform(\n  transform: Array<Object>,\n): Array<Object> | Array<number> {\n  if (__DEV__) {\n    _validateTransforms(transform);\n  }\n\n  // Android & iOS implementations of transform property accept the list of\n  // transform properties as opposed to a transform Matrix. This is necessary\n  // to control transform property updates completely on the native thread.\n  if (Platform.OS === 'android' || Platform.OS === 'ios') {\n    return transform;\n  }\n\n  const result = MatrixMath.createIdentityMatrix();\n\n  transform.forEach(transformation => {\n    const key = Object.keys(transformation)[0];\n    const value = transformation[key];\n\n    switch (key) {\n      case 'matrix':\n        MatrixMath.multiplyInto(result, result, value);\n        break;\n      case 'perspective':\n        _multiplyTransform(result, MatrixMath.reusePerspectiveCommand, [value]);\n        break;\n      case 'rotateX':\n        _multiplyTransform(result, MatrixMath.reuseRotateXCommand, [\n          _convertToRadians(value),\n        ]);\n        break;\n      case 'rotateY':\n        _multiplyTransform(result, MatrixMath.reuseRotateYCommand, [\n          _convertToRadians(value),\n        ]);\n        break;\n      case 'rotate':\n      case 'rotateZ':\n        _multiplyTransform(result, MatrixMath.reuseRotateZCommand, [\n          _convertToRadians(value),\n        ]);\n        break;\n      case 'scale':\n        _multiplyTransform(result, MatrixMath.reuseScaleCommand, [value]);\n        break;\n      case 'scaleX':\n        _multiplyTransform(result, MatrixMath.reuseScaleXCommand, [value]);\n        break;\n      case 'scaleY':\n        _multiplyTransform(result, MatrixMath.reuseScaleYCommand, [value]);\n        break;\n      case 'translate':\n        _multiplyTransform(result, MatrixMath.reuseTranslate3dCommand, [\n          value[0],\n          value[1],\n          value[2] || 0,\n        ]);\n        break;\n      case 'translateX':\n        _multiplyTransform(result, MatrixMath.reuseTranslate2dCommand, [\n          value,\n          0,\n        ]);\n        break;\n      case 'translateY':\n        _multiplyTransform(result, MatrixMath.reuseTranslate2dCommand, [\n          0,\n          value,\n        ]);\n        break;\n      case 'skewX':\n        _multiplyTransform(result, MatrixMath.reuseSkewXCommand, [\n          _convertToRadians(value),\n        ]);\n        break;\n      case 'skewY':\n        _multiplyTransform(result, MatrixMath.reuseSkewYCommand, [\n          _convertToRadians(value),\n        ]);\n        break;\n      default:\n        throw new Error('Invalid transform name: ' + key);\n    }\n  });\n\n  return result;\n}\n\n/**\n * Performs a destructive operation on a transform matrix.\n */\nfunction _multiplyTransform(\n  result: Array<number>,\n  matrixMathFunction: Function,\n  args: Array<number>,\n): void {\n  const matrixToApply = MatrixMath.createIdentityMatrix();\n  const argsWithIdentity = [matrixToApply].concat(args);\n  matrixMathFunction.apply(this, argsWithIdentity);\n  MatrixMath.multiplyInto(result, result, matrixToApply);\n}\n\n/**\n * Parses a string like '0.5rad' or '60deg' into radians expressed in a float.\n * Note that validation on the string is done in `_validateTransform()`.\n */\nfunction _convertToRadians(value: string): number {\n  const floatValue = parseFloat(value);\n  return value.indexOf('rad') > -1 ? floatValue : (floatValue * Math.PI) / 180;\n}\n\nfunction _validateTransforms(transform: Array<Object>): void {\n  transform.forEach(transformation => {\n    const keys = Object.keys(transformation);\n    invariant(\n      keys.length === 1,\n      'You must specify exactly one property per transform object. Passed properties: %s',\n      stringifySafe(transformation),\n    );\n    const key = keys[0];\n    const value = transformation[key];\n    _validateTransform(key, value, transformation);\n  });\n}\n\nfunction _validateTransform(key, value, transformation) {\n  invariant(\n    !value.getValue,\n    'You passed an Animated.Value to a normal component. ' +\n      'You need to wrap that component in an Animated. For example, ' +\n      'replace <View /> by <Animated.View />.',\n  );\n\n  const multivalueTransforms = ['matrix', 'translate'];\n  if (multivalueTransforms.indexOf(key) !== -1) {\n    invariant(\n      Array.isArray(value),\n      'Transform with key of %s must have an array as the value: %s',\n      key,\n      stringifySafe(transformation),\n    );\n  }\n  switch (key) {\n    case 'matrix':\n      invariant(\n        value.length === 9 || value.length === 16,\n        'Matrix transform must have a length of 9 (2d) or 16 (3d). ' +\n          'Provided matrix has a length of %s: %s',\n        value.length,\n        stringifySafe(transformation),\n      );\n      break;\n    case 'translate':\n      invariant(\n        value.length === 2 || value.length === 3,\n        'Transform with key translate must be an array of length 2 or 3, found %s: %s',\n        value.length,\n        stringifySafe(transformation),\n      );\n      break;\n    case 'rotateX':\n    case 'rotateY':\n    case 'rotateZ':\n    case 'rotate':\n    case 'skewX':\n    case 'skewY':\n      invariant(\n        typeof value === 'string',\n        'Transform with key of \"%s\" must be a string: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      invariant(\n        value.indexOf('deg') > -1 || value.indexOf('rad') > -1,\n        'Rotate transform must be expressed in degrees (deg) or radians ' +\n          '(rad): %s',\n        stringifySafe(transformation),\n      );\n      break;\n    case 'perspective':\n      invariant(\n        typeof value === 'number',\n        'Transform with key of \"%s\" must be a number: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      invariant(\n        value !== 0,\n        'Transform with key of \"%s\" cannot be zero: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      break;\n    case 'translateX':\n    case 'translateY':\n    case 'scale':\n    case 'scaleX':\n    case 'scaleY':\n      invariant(\n        typeof value === 'number',\n        'Transform with key of \"%s\" must be a number: %s',\n        key,\n        stringifySafe(transformation),\n      );\n      break;\n    default:\n      invariant(\n        false,\n        'Invalid transform %s: %s',\n        key,\n        stringifySafe(transformation),\n      );\n  }\n}\n\nmodule.exports = processTransform;\n"],"names":["require","d","module","exports","transform"],"mappings":"4BAUA,aAEmBA,EAAOC,EAAA,IACTD,EAAOC,EAAA,IAEND,EAAOC,EAAA,IACHD,EAAOC,EAAA,IAkO7BC,EAAOC,QAxNP,SACEC,GAUE,OAAOA","file":"84.js"}