{"version":3,"sources":["/Users/jamielynch/repos/bugsnag-react-native/examples/plain/node_modules/react-native/Libraries/BatchedBridge/MessageQueue.js"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nconst ErrorUtils = require('ErrorUtils');\nconst Systrace = require('Systrace');\n\nconst deepFreezeAndThrowOnMutationInDev = require('deepFreezeAndThrowOnMutationInDev');\nconst invariant = require('fbjs/lib/invariant');\nconst stringifySafe = require('stringifySafe');\n\nexport type SpyData = {\n  type: number,\n  module: ?string,\n  method: string | number,\n  args: any[],\n};\n\nconst TO_JS = 0;\nconst TO_NATIVE = 1;\n\nconst MODULE_IDS = 0;\nconst METHOD_IDS = 1;\nconst PARAMS = 2;\nconst MIN_TIME_BETWEEN_FLUSHES_MS = 5;\n\n// eslint-disable-next-line no-bitwise\nconst TRACE_TAG_REACT_APPS = 1 << 17;\n\nconst DEBUG_INFO_LIMIT = 32;\n\nclass MessageQueue {\n  _lazyCallableModules: {[key: string]: (void) => Object};\n  _queue: [number[], number[], any[], number];\n  _successCallbacks: {[key: number]: ?Function};\n  _failureCallbacks: {[key: number]: ?Function};\n  _callID: number;\n  _lastFlush: number;\n  _eventLoopStartTime: number;\n  _immediatesCallback: ?() => void;\n\n  _debugInfo: {[number]: [number, number]};\n  _remoteModuleTable: {[number]: string};\n  _remoteMethodTable: {[number]: string[]};\n\n  __spy: ?(data: SpyData) => void;\n\n  constructor() {\n    this._lazyCallableModules = {};\n    this._queue = [[], [], [], 0];\n    this._successCallbacks = {};\n    this._failureCallbacks = {};\n    this._callID = 0;\n    this._lastFlush = 0;\n    this._eventLoopStartTime = Date.now();\n    this._immediatesCallback = null;\n\n    if (__DEV__) {\n      this._debugInfo = {};\n      this._remoteModuleTable = {};\n      this._remoteMethodTable = {};\n    }\n\n    (this: any).callFunctionReturnFlushedQueue = this.callFunctionReturnFlushedQueue.bind(\n      this,\n    );\n    (this: any).callFunctionReturnResultAndFlushedQueue = this.callFunctionReturnResultAndFlushedQueue.bind(\n      this,\n    );\n    (this: any).flushedQueue = this.flushedQueue.bind(this);\n    (this: any).invokeCallbackAndReturnFlushedQueue = this.invokeCallbackAndReturnFlushedQueue.bind(\n      this,\n    );\n  }\n\n  /**\n   * Public APIs\n   */\n\n  static spy(spyOrToggle: boolean | ((data: SpyData) => void)) {\n    if (spyOrToggle === true) {\n      MessageQueue.prototype.__spy = info => {\n        console.log(\n          `${info.type === TO_JS ? 'N->JS' : 'JS->N'} : ` +\n            `${info.module ? info.module + '.' : ''}${info.method}` +\n            `(${JSON.stringify(info.args)})`,\n        );\n      };\n    } else if (spyOrToggle === false) {\n      MessageQueue.prototype.__spy = null;\n    } else {\n      MessageQueue.prototype.__spy = spyOrToggle;\n    }\n  }\n\n  callFunctionReturnFlushedQueue(module: string, method: string, args: any[]) {\n    this.__guard(() => {\n      this.__callFunction(module, method, args);\n    });\n\n    return this.flushedQueue();\n  }\n\n  callFunctionReturnResultAndFlushedQueue(\n    module: string,\n    method: string,\n    args: any[],\n  ) {\n    let result;\n    this.__guard(() => {\n      result = this.__callFunction(module, method, args);\n    });\n\n    return [result, this.flushedQueue()];\n  }\n\n  invokeCallbackAndReturnFlushedQueue(cbID: number, args: any[]) {\n    this.__guard(() => {\n      this.__invokeCallback(cbID, args);\n    });\n\n    return this.flushedQueue();\n  }\n\n  flushedQueue() {\n    this.__guard(() => {\n      this.__callImmediates();\n    });\n\n    const queue = this._queue;\n    this._queue = [[], [], [], this._callID];\n    return queue[0].length ? queue : null;\n  }\n\n  getEventLoopRunningTime() {\n    return Date.now() - this._eventLoopStartTime;\n  }\n\n  registerCallableModule(name: string, module: Object) {\n    this._lazyCallableModules[name] = () => module;\n  }\n\n  registerLazyCallableModule(name: string, factory: void => Object) {\n    let module: Object;\n    let getValue: ?(void) => Object = factory;\n    this._lazyCallableModules[name] = () => {\n      if (getValue) {\n        module = getValue();\n        getValue = null;\n      }\n      return module;\n    };\n  }\n\n  getCallableModule(name: string) {\n    const getValue = this._lazyCallableModules[name];\n    return getValue ? getValue() : null;\n  }\n\n  enqueueNativeCall(\n    moduleID: number,\n    methodID: number,\n    params: any[],\n    onFail: ?Function,\n    onSucc: ?Function,\n  ) {\n    if (onFail || onSucc) {\n      if (__DEV__) {\n        this._debugInfo[this._callID] = [moduleID, methodID];\n        if (this._callID > DEBUG_INFO_LIMIT) {\n          delete this._debugInfo[this._callID - DEBUG_INFO_LIMIT];\n        }\n      }\n      // Encode callIDs into pairs of callback identifiers by shifting left and using the rightmost bit\n      // to indicate fail (0) or success (1)\n      // eslint-disable-next-line no-bitwise\n      onFail && params.push(this._callID << 1);\n      // eslint-disable-next-line no-bitwise\n      onSucc && params.push((this._callID << 1) | 1);\n      this._successCallbacks[this._callID] = onSucc;\n      this._failureCallbacks[this._callID] = onFail;\n    }\n\n    if (__DEV__) {\n      global.nativeTraceBeginAsyncFlow &&\n        global.nativeTraceBeginAsyncFlow(\n          TRACE_TAG_REACT_APPS,\n          'native',\n          this._callID,\n        );\n    }\n    this._callID++;\n\n    this._queue[MODULE_IDS].push(moduleID);\n    this._queue[METHOD_IDS].push(methodID);\n\n    if (__DEV__) {\n      // Validate that parameters passed over the bridge are\n      // folly-convertible.  As a special case, if a prop value is a\n      // function it is permitted here, and special-cased in the\n      // conversion.\n      const isValidArgument = val => {\n        const t = typeof val;\n        if (\n          t === 'undefined' ||\n          t === 'null' ||\n          t === 'boolean' ||\n          t === 'number' ||\n          t === 'string'\n        ) {\n          return true;\n        }\n        if (t === 'function' || t !== 'object') {\n          return false;\n        }\n        if (Array.isArray(val)) {\n          return val.every(isValidArgument);\n        }\n        for (const k in val) {\n          if (typeof val[k] !== 'function' && !isValidArgument(val[k])) {\n            return false;\n          }\n        }\n        return true;\n      };\n\n      invariant(\n        isValidArgument(params),\n        '%s is not usable as a native method argument',\n        params,\n      );\n\n      // The params object should not be mutated after being queued\n      deepFreezeAndThrowOnMutationInDev((params: any));\n    }\n    this._queue[PARAMS].push(params);\n\n    const now = Date.now();\n    if (\n      global.nativeFlushQueueImmediate &&\n      now - this._lastFlush >= MIN_TIME_BETWEEN_FLUSHES_MS\n    ) {\n      const queue = this._queue;\n      this._queue = [[], [], [], this._callID];\n      this._lastFlush = now;\n      global.nativeFlushQueueImmediate(queue);\n    }\n    Systrace.counterEvent('pending_js_to_native_queue', this._queue[0].length);\n    if (__DEV__ && this.__spy && isFinite(moduleID)) {\n      this.__spy({\n        type: TO_NATIVE,\n        module: this._remoteModuleTable[moduleID],\n        method: this._remoteMethodTable[moduleID][methodID],\n        args: params,\n      });\n    } else if (this.__spy) {\n      this.__spy({\n        type: TO_NATIVE,\n        module: moduleID + '',\n        method: methodID,\n        args: params,\n      });\n    }\n  }\n\n  createDebugLookup(moduleID: number, name: string, methods: string[]) {\n    if (__DEV__) {\n      this._remoteModuleTable[moduleID] = name;\n      this._remoteMethodTable[moduleID] = methods;\n    }\n  }\n\n  // For JSTimers to register its callback. Otherwise a circular dependency\n  // between modules is introduced. Note that only one callback may be\n  // registered at a time.\n  setImmediatesCallback(fn: () => void) {\n    this._immediatesCallback = fn;\n  }\n\n  /**\n   * Private methods\n   */\n\n  __guard(fn: () => void) {\n    if (this.__shouldPauseOnThrow()) {\n      fn();\n    } else {\n      try {\n        fn();\n      } catch (error) {\n        ErrorUtils.reportFatalError(error);\n      }\n    }\n  }\n\n  // MessageQueue installs a global handler to catch all exceptions where JS users can register their own behavior\n  // This handler makes all exceptions to be propagated from inside MessageQueue rather than by the VM at their origin\n  // This makes stacktraces to be placed at MessageQueue rather than at where they were launched\n  // The parameter DebuggerInternal.shouldPauseOnThrow is used to check before catching all exceptions and\n  // can be configured by the VM or any Inspector\n  __shouldPauseOnThrow() {\n    return (\n      // $FlowFixMe\n      typeof DebuggerInternal !== 'undefined' &&\n      DebuggerInternal.shouldPauseOnThrow === true // eslint-disable-line no-undef\n    );\n  }\n\n  __callImmediates() {\n    Systrace.beginEvent('JSTimers.callImmediates()');\n    if (this._immediatesCallback != null) {\n      this._immediatesCallback();\n    }\n    Systrace.endEvent();\n  }\n\n  __callFunction(module: string, method: string, args: any[]): any {\n    this._lastFlush = Date.now();\n    this._eventLoopStartTime = this._lastFlush;\n    if (__DEV__ || this.__spy) {\n      Systrace.beginEvent(`${module}.${method}(${stringifySafe(args)})`);\n    } else {\n      Systrace.beginEvent(`${module}.${method}(...)`);\n    }\n    if (this.__spy) {\n      this.__spy({type: TO_JS, module, method, args});\n    }\n    const moduleMethods = this.getCallableModule(module);\n    invariant(\n      !!moduleMethods,\n      'Module %s is not a registered callable module (calling %s)',\n      module,\n      method,\n    );\n    invariant(\n      !!moduleMethods[method],\n      'Method %s does not exist on module %s',\n      method,\n      module,\n    );\n    const result = moduleMethods[method].apply(moduleMethods, args);\n    Systrace.endEvent();\n    return result;\n  }\n\n  __invokeCallback(cbID: number, args: any[]) {\n    this._lastFlush = Date.now();\n    this._eventLoopStartTime = this._lastFlush;\n\n    // The rightmost bit of cbID indicates fail (0) or success (1), the other bits are the callID shifted left.\n    // eslint-disable-next-line no-bitwise\n    const callID = cbID >>> 1;\n    // eslint-disable-next-line no-bitwise\n    const isSuccess = cbID & 1;\n    const callback = isSuccess\n      ? this._successCallbacks[callID]\n      : this._failureCallbacks[callID];\n\n    if (__DEV__) {\n      const debug = this._debugInfo[callID];\n      const module = debug && this._remoteModuleTable[debug[0]];\n      const method = debug && this._remoteMethodTable[debug[0]][debug[1]];\n      if (!callback) {\n        let errorMessage = `Callback with id ${cbID}: ${module}.${method}() not found`;\n        if (method) {\n          errorMessage =\n            `The callback ${method}() exists in module ${module}, ` +\n            'but only one callback may be registered to a function in a native module.';\n        }\n        invariant(callback, errorMessage);\n      }\n      const profileName = debug\n        ? '<callback for ' + module + '.' + method + '>'\n        : cbID;\n      if (callback && this.__spy) {\n        this.__spy({type: TO_JS, module: null, method: profileName, args});\n      }\n      Systrace.beginEvent(\n        `MessageQueue.invokeCallback(${profileName}, ${stringifySafe(args)})`,\n      );\n    }\n\n    if (!callback) {\n      return;\n    }\n\n    delete this._successCallbacks[callID];\n    delete this._failureCallbacks[callID];\n    callback(...args);\n\n    if (__DEV__) {\n      Systrace.endEvent();\n    }\n  }\n}\n\nmodule.exports = MessageQueue;\n"],"names":["ErrorUtils","require","d","Systrace","invariant","stringifySafe","MessageQueue","_classCallCheck","this","_lazyCallableModules","_queue","_successCallbacks","_failureCallbacks","_callID","_lastFlush","_eventLoopStartTime","Date","now","_immediatesCallback","callFunctionReturnFlushedQueue","bind","callFunctionReturnResultAndFlushedQueue","flushedQueue","invokeCallbackAndReturnFlushedQueue","module","method","args","_this","__guard","__callFunction","result","_this2","cbID","_this3","__invokeCallback","_this4","__callImmediates","queue","length","name","factory","getValue","moduleID","methodID","params","onFail","onSucc","push","global","nativeFlushQueueImmediate","counterEvent","__spy","type","methods","fn","__shouldPauseOnThrow","error","reportFatalError","DebuggerInternal","shouldPauseOnThrow","beginEvent","endEvent","moduleMethods","getCallableModule","apply","callID","callback","undefined","_toConsumableArray","spyOrToggle","prototype","info","console","log","JSON","stringify","exports"],"mappings":"4BAUA,+CAEMA,EAAaC,EAAOC,EAAA,IACpBC,EAAWF,EAAOC,EAAA,IAGlBE,GADoCH,EAAOC,EAAA,IAC/BD,EAAOC,EAAA,KACnBG,EAAgBJ,EAAOC,EAAA,IAsBvBI,cAgBJ,SAAAA,IAAcC,EAAAC,KAAAF,GACZE,KAAKC,wBACLD,KAAKE,iBAAsB,GAC3BF,KAAKG,qBACLH,KAAKI,qBACLJ,KAAKK,QAAU,EACfL,KAAKM,WAAa,EAClBN,KAAKO,oBAAsBC,KAAKC,MAChCT,KAAKU,oBAAsB,KAQ1BV,KAAWW,+BAAiCX,KAAKW,+BAA+BC,KAC/EZ,MAEDA,KAAWa,wCAA0Cb,KAAKa,wCAAwCD,KACjGZ,MAEDA,KAAWc,aAAed,KAAKc,aAAaF,KAAKZ,MACjDA,KAAWe,oCAAsCf,KAAKe,oCAAoCH,KACzFZ,uEAwB2BgB,EAAgBC,EAAgBC,GAAa,IAAAC,EAAAnB,KAK1E,OAJAA,KAAKoB,QAAQ,WACXD,EAAKE,eAAeL,EAAQC,EAAQC,KAG/BlB,KAAKc,+EAIZE,EACAC,EACAC,GACA,IACII,EADJC,EAAAvB,KAMA,OAJAA,KAAKoB,QAAQ,WACXE,EAASC,EAAKF,eAAeL,EAAQC,EAAQC,MAGvCI,EAAQtB,KAAKc,4EAGaU,EAAcN,GAAa,IAAAO,EAAAzB,KAK7D,OAJAA,KAAKoB,QAAQ,WACXK,EAAKC,iBAAiBF,EAAMN,KAGvBlB,KAAKc,sDAGC,IAAAa,EAAA3B,KACbA,KAAKoB,QAAQ,WACXO,EAAKC,qBAGP,IAAMC,EAAQ7B,KAAKE,OAEnB,OADAF,KAAKE,iBAAsBF,KAAKK,SACzBwB,EAAM,GAAGC,OAASD,EAAQ,uDAIjC,OAAOrB,KAAKC,MAAQT,KAAKO,mEAGJwB,EAAcf,GACnChB,KAAKC,qBAAqB8B,GAAQ,WAAA,OAAMf,sDAGfe,EAAcC,GACvC,IAAIhB,EACAiB,EAA8BD,EAClChC,KAAKC,qBAAqB8B,GAAQ,WAKhC,OAJIE,IACFjB,EAASiB,IACTA,EAAW,MAENjB,6CAIOe,GAChB,IAAME,EAAWjC,KAAKC,qBAAqB8B,GAC3C,OAAOE,EAAWA,IAAa,+CAI/BC,EACAC,EACAC,EACAC,EACAC,IAEID,GAAUC,KAUZD,GAAUD,EAAOG,KAAKvC,KAAKK,SAAW,GAEtCiC,GAAUF,EAAOG,KAAMvC,KAAKK,SAAW,EAAK,GAC5CL,KAAKG,kBAAkBH,KAAKK,SAAWiC,EACvCtC,KAAKI,kBAAkBJ,KAAKK,SAAWgC,GAWzCrC,KAAKK,UAELL,KAAKE,OA5KU,GA4KSqC,KAAKL,GAC7BlC,KAAKE,OA5KU,GA4KSqC,KAAKJ,GAyC7BnC,KAAKE,OApNM,GAoNSqC,KAAKH,GAEzB,IAAM3B,EAAMD,KAAKC,MACjB,GACE+B,EAAOC,2BACPhC,EAAMT,KAAKM,YAxNmB,EAyN9B,CACA,IAAMuB,EAAQ7B,KAAKE,OACnBF,KAAKE,iBAAsBF,KAAKK,SAChCL,KAAKM,WAAaG,EAClB+B,EAAOC,0BAA0BZ,GAEnClC,EAAS+C,aAAa,6BAA8B1C,KAAKE,OAAO,GAAG4B,QAQxD9B,KAAK2C,OACd3C,KAAK2C,OACHC,KA9OU,EA+OV5B,OAAQkB,EAAW,GACnBjB,OAAQkB,EACRjB,KAAMkB,8CAKMF,EAAkBH,EAAcc,kDAU5BC,GACpB9C,KAAKU,oBAAsBoC,kCAOrBA,GACN,GAAI9C,KAAK+C,uBACPD,SAEA,IACEA,IACA,MAAOE,GACPxD,EAAWyD,iBAAiBD,mDAWhC,MAE8B,oBAArBE,mBACiC,IAAxCA,iBAAiBC,8DAKnBxD,EAASyD,WAAW,6BACY,MAA5BpD,KAAKU,qBACPV,KAAKU,sBAEPf,EAAS0D,kDAGIrC,EAAgBC,EAAgBC,GAC7ClB,KAAKM,WAAaE,KAAKC,MACvBT,KAAKO,oBAAsBP,KAAKM,WACjBN,KAAK2C,MAClBhD,EAASyD,WAAcpC,EAAvB,IAAiCC,EAAjC,IAA2CpB,EAAcqB,GAAzD,KAEAvB,EAASyD,WAAcpC,EAAvB,IAAiCC,EAAjC,SAEEjB,KAAK2C,OACP3C,KAAK2C,OAAOC,KAnTJ,EAmTiB5B,OAAAA,EAAQC,OAAAA,EAAQC,KAAAA,IAE3C,IAAMoC,EAAgBtD,KAAKuD,kBAAkBvC,GAC7CpB,IACI0D,EACF,6DACAtC,EACAC,GAEFrB,IACI0D,EAAcrC,GAChB,wCACAA,EACAD,GAEF,IAAMM,EAASgC,EAAcrC,GAAQuC,MAAMF,EAAepC,GAE1D,OADAvB,EAAS0D,WACF/B,2CAGQE,EAAcN,GAC7BlB,KAAKM,WAAaE,KAAKC,MACvBT,KAAKO,oBAAsBP,KAAKM,WAIhC,IAAMmD,EAASjC,IAAS,EAGlBkC,EADmB,EAAPlC,EAEdxB,KAAKG,kBAAkBsD,GACvBzD,KAAKI,kBAAkBqD,GA0BtBC,WAIE1D,KAAKG,kBAAkBsD,UACvBzD,KAAKI,kBAAkBqD,GAC9BC,EAAQF,WAARG,EAAAC,EAAY1C,mCArTH2C,GAEP/D,EAAagE,UAAUnB,OADL,IAAhBkB,EAC6B,SAAAE,GAC7BC,QAAQC,KAhEF,IAiEDF,EAAKnB,KAAiB,QAAU,SAAnC,OACKmB,EAAK/C,OAAS+C,EAAK/C,OAAS,IAAM,IAAK+C,EAAK9C,OADjD,IAEMiD,KAAKC,UAAUJ,EAAK7C,MAF1B,OAKqB,IAAhB2C,EACsB,KAEAA,YAiTrC7C,EAAOoD,QAAUtE","file":"39.js"}