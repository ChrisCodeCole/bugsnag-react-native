{"version":3,"sources":["/Users/jamielynch/repos/bugsnag-react-native/examples/plain/node_modules/react-native/Libraries/vendor/core/Map.js"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @preventMunge\n * @typechecks\n */\n\n/* eslint-disable no-extend-native, no-shadow-restricted-names */\n\n'use strict';\n\nconst _shouldPolyfillES6Collection = require('_shouldPolyfillES6Collection');\nconst guid = require('guid');\nconst isNode = require('fbjs/lib/isNode');\nconst toIterator = require('toIterator');\n\nmodule.exports = (function(global, undefined) {\n  // Since our implementation is spec-compliant for the most part we can safely\n  // delegate to a built-in version if exists and is implemented correctly.\n  // Firefox had gotten a few implementation details wrong across different\n  // versions so we guard against that.\n  if (!_shouldPolyfillES6Collection('Map')) {\n    return global.Map;\n  }\n\n  /**\n   * == ES6 Map Collection ==\n   *\n   * This module is meant to implement a Map collection as described in chapter\n   * 23.1 of the ES6 specification.\n   *\n   * Map objects are collections of key/value pairs where both the keys and\n   * values may be arbitrary ECMAScript language values. A distinct key value\n   * may only occur in one key/value pair within the Map's collection.\n   *\n   * https://people.mozilla.org/~jorendorff/es6-draft.html#sec-map-objects\n   *\n   * There only two -- rather small -- diviations from the spec:\n   *\n   * 1. The use of frozen objects as keys.\n   *    We decided not to allow and simply throw an error. The reason being is\n   *    we store a \"hash\" on the object for fast access to it's place in the\n   *    internal map entries.\n   *    If this turns out to be a popular use case it's possible to implement by\n   *    overiding `Object.freeze` to store a \"hash\" property on the object\n   *    for later use with the map.\n   *\n   * 2. The `size` property on a map object is a regular property and not a\n   *    computed property on the prototype as described by the spec.\n   *    The reason being is that we simply want to support ES3 environments\n   *    which doesn't implement computed properties.\n   *\n   * == Usage ==\n   *\n   * var map = new Map(iterable);\n   *\n   * map.set(key, value);\n   * map.get(key); // value\n   * map.has(key); // true\n   * map.delete(key); // true\n   *\n   * var iterator = map.keys();\n   * iterator.next(); // {value: key, done: false}\n   *\n   * var iterator = map.values();\n   * iterator.next(); // {value: value, done: false}\n   *\n   * var iterator = map.entries();\n   * iterator.next(); // {value: [key, value], done: false}\n   *\n   * map.forEach(function(value, key){ this === thisArg }, thisArg);\n   *\n   * map.clear(); // resets map.\n   */\n\n  /**\n   * Constants\n   */\n\n  // Kinds of map iterations 23.1.5.3\n  const KIND_KEY = 'key';\n  const KIND_VALUE = 'value';\n  const KIND_KEY_VALUE = 'key+value';\n\n  // In older browsers we can't create a null-prototype object so we have to\n  // defend against key collisions with built-in methods.\n  const KEY_PREFIX = '$map_';\n\n  // This property will be used as the internal size variable to disallow\n  // writing and to issue warnings for writings in development.\n  let SECRET_SIZE_PROP;\n  if (__DEV__) {\n    SECRET_SIZE_PROP = '$size' + guid();\n  }\n\n  // In oldIE we use the DOM Node `uniqueID` property to get create the hash.\n  const OLD_IE_HASH_PREFIX = 'IE_HASH_';\n\n  class Map {\n    /**\n     * 23.1.1.1\n     * Takes an `iterable` which is basically any object that implements a\n     * Symbol.iterator (@@iterator) method. The iterable is expected to be a\n     * collection of pairs. Each pair is a key/value pair that will be used\n     * to instantiate the map.\n     *\n     * @param {*} iterable\n     */\n    constructor(iterable) {\n      if (!isObject(this)) {\n        throw new TypeError('Wrong map object type.');\n      }\n\n      initMap(this);\n\n      if (iterable != null) {\n        const it = toIterator(iterable);\n        let next;\n        while (!(next = it.next()).done) {\n          if (!isObject(next.value)) {\n            throw new TypeError('Expected iterable items to be pair objects.');\n          }\n          this.set(next.value[0], next.value[1]);\n        }\n      }\n    }\n\n    /**\n     * 23.1.3.1\n     * Clears the map from all keys and values.\n     */\n    clear() {\n      initMap(this);\n    }\n\n    /**\n     * 23.1.3.7\n     * Check if a key exists in the collection.\n     *\n     * @param {*} key\n     * @return {boolean}\n     */\n    has(key) {\n      const index = getIndex(this, key);\n      return !!(index != null && this._mapData[index]);\n    }\n\n    /**\n     * 23.1.3.9\n     * Adds a key/value pair to the collection.\n     *\n     * @param {*} key\n     * @param {*} value\n     * @return {map}\n     */\n    set(key, value) {\n      let index = getIndex(this, key);\n\n      if (index != null && this._mapData[index]) {\n        this._mapData[index][1] = value;\n      } else {\n        index = this._mapData.push([key, value]) - 1;\n        setIndex(this, key, index);\n        if (__DEV__) {\n          this[SECRET_SIZE_PROP] += 1;\n        } else {\n          this.size += 1;\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * 23.1.3.6\n     * Gets a value associated with a key in the collection.\n     *\n     * @param {*} key\n     * @return {*}\n     */\n    get(key) {\n      const index = getIndex(this, key);\n      if (index == null) {\n        return undefined;\n      } else {\n        return this._mapData[index][1];\n      }\n    }\n\n    /**\n     * 23.1.3.3\n     * Delete a key/value from the collection.\n     *\n     * @param {*} key\n     * @return {boolean} Whether the key was found and deleted.\n     */\n    delete(key) {\n      const index = getIndex(this, key);\n      if (index != null && this._mapData[index]) {\n        setIndex(this, key, undefined);\n        this._mapData[index] = undefined;\n        if (__DEV__) {\n          this[SECRET_SIZE_PROP] -= 1;\n        } else {\n          this.size -= 1;\n        }\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * 23.1.3.4\n     * Returns an iterator over the key/value pairs (in the form of an Array) in\n     * the collection.\n     *\n     * @return {MapIterator}\n     */\n    entries() {\n      return new MapIterator(this, KIND_KEY_VALUE);\n    }\n\n    /**\n     * 23.1.3.8\n     * Returns an iterator over the keys in the collection.\n     *\n     * @return {MapIterator}\n     */\n    keys() {\n      return new MapIterator(this, KIND_KEY);\n    }\n\n    /**\n     * 23.1.3.11\n     * Returns an iterator over the values pairs in the collection.\n     *\n     * @return {MapIterator}\n     */\n    values() {\n      return new MapIterator(this, KIND_VALUE);\n    }\n\n    /**\n     * 23.1.3.5\n     * Iterates over the key/value pairs in the collection calling `callback`\n     * with [value, key, map]. An optional `thisArg` can be passed to set the\n     * context when `callback` is called.\n     *\n     * @param {function} callback\n     * @param {?object} thisArg\n     */\n    forEach(callback, thisArg) {\n      if (typeof callback !== 'function') {\n        throw new TypeError('Callback must be callable.');\n      }\n\n      const boundCallback = callback.bind(thisArg || undefined);\n      const mapData = this._mapData;\n\n      // Note that `mapData.length` should be computed on each iteration to\n      // support iterating over new items in the map that were added after the\n      // start of the iteration.\n      for (let i = 0; i < mapData.length; i++) {\n        const entry = mapData[i];\n        if (entry != null) {\n          boundCallback(entry[1], entry[0], this);\n        }\n      }\n    }\n  }\n\n  // 23.1.3.12\n  Map.prototype[toIterator.ITERATOR_SYMBOL] = Map.prototype.entries;\n\n  class MapIterator {\n    /**\n     * 23.1.5.1\n     * Create a `MapIterator` for a given `map`. While this class is private it\n     * will create objects that will be passed around publicily.\n     *\n     * @param {map} map\n     * @param {string} kind\n     */\n    constructor(map, kind) {\n      if (!(isObject(map) && map._mapData)) {\n        throw new TypeError('Object is not a map.');\n      }\n\n      if ([KIND_KEY, KIND_KEY_VALUE, KIND_VALUE].indexOf(kind) === -1) {\n        throw new Error('Invalid iteration kind.');\n      }\n\n      this._map = map;\n      this._nextIndex = 0;\n      this._kind = kind;\n    }\n\n    /**\n     * 23.1.5.2.1\n     * Get the next iteration.\n     *\n     * @return {object}\n     */\n    next() {\n      if (!this instanceof Map) {\n        throw new TypeError('Expected to be called on a MapIterator.');\n      }\n\n      const map = this._map;\n      let index = this._nextIndex;\n      const kind = this._kind;\n\n      if (map == null) {\n        return createIterResultObject(undefined, true);\n      }\n\n      const entries = map._mapData;\n\n      while (index < entries.length) {\n        const record = entries[index];\n\n        index += 1;\n        this._nextIndex = index;\n\n        if (record) {\n          if (kind === KIND_KEY) {\n            return createIterResultObject(record[0], false);\n          } else if (kind === KIND_VALUE) {\n            return createIterResultObject(record[1], false);\n          } else if (kind) {\n            return createIterResultObject(record, false);\n          }\n        }\n      }\n\n      this._map = undefined;\n\n      return createIterResultObject(undefined, true);\n    }\n  }\n\n  // We can put this in the class definition once we have computed props\n  // transform.\n  // 23.1.5.2.2\n  MapIterator.prototype[toIterator.ITERATOR_SYMBOL] = function() {\n    return this;\n  };\n\n  /**\n   * Helper Functions.\n   */\n\n  /**\n   * Return an index to map.[[MapData]] array for a given Key.\n   *\n   * @param {map} map\n   * @param {*} key\n   * @return {?number}\n   */\n  function getIndex(map, key) {\n    if (isObject(key)) {\n      const hash = getHash(key);\n      return map._objectIndex[hash];\n    } else {\n      const prefixedKey = KEY_PREFIX + key;\n      if (typeof key === 'string') {\n        return map._stringIndex[prefixedKey];\n      } else {\n        return map._otherIndex[prefixedKey];\n      }\n    }\n  }\n\n  /**\n   * Setup an index that refer to the key's location in map.[[MapData]].\n   *\n   * @param {map} map\n   * @param {*} key\n   */\n  function setIndex(map, key, index) {\n    const shouldDelete = index == null;\n\n    if (isObject(key)) {\n      const hash = getHash(key);\n      if (shouldDelete) {\n        delete map._objectIndex[hash];\n      } else {\n        map._objectIndex[hash] = index;\n      }\n    } else {\n      const prefixedKey = KEY_PREFIX + key;\n      if (typeof key === 'string') {\n        if (shouldDelete) {\n          delete map._stringIndex[prefixedKey];\n        } else {\n          map._stringIndex[prefixedKey] = index;\n        }\n      } else {\n        if (shouldDelete) {\n          delete map._otherIndex[prefixedKey];\n        } else {\n          map._otherIndex[prefixedKey] = index;\n        }\n      }\n    }\n  }\n\n  /**\n   * Instantiate a map with internal slots.\n   *\n   * @param {map} map\n   */\n  function initMap(map) {\n    // Data structure design inspired by Traceur's Map implementation.\n    // We maintain an internal array for all the entries. The array is needed\n    // to remember order. However, to have a reasonable HashMap performance\n    // i.e. O(1) for insertion, deletion, and retrieval. We maintain indices\n    // in objects for fast look ups. Indices are split up according to data\n    // types to avoid collisions.\n    map._mapData = [];\n\n    // Object index maps from an object \"hash\" to index. The hash being a unique\n    // property of our choosing that we associate with the object. Association\n    // is done by ways of keeping a non-enumerable property on the object.\n    // Ideally these would be `Object.create(null)` objects but since we're\n    // trying to support ES3 we'll have to guard against collisions using\n    // prefixes on the keys rather than rely on null prototype objects.\n    map._objectIndex = {};\n\n    // String index maps from strings to index.\n    map._stringIndex = {};\n\n    // Numbers, booleans, undefined, and null.\n    map._otherIndex = {};\n\n    // Unfortunately we have to support ES3 and cannot have `Map.prototype.size`\n    // be a getter method but just a regular method. The biggest problem with\n    // this is safety. Clients can change the size property easily and possibly\n    // without noticing (e.g. `if (map.size = 1) {..}` kind of typo). What we\n    // can do to mitigate use getters and setters in development to disallow\n    // and issue a warning for changing the `size` property.\n    if (__DEV__) {\n      if (isES5) {\n        // If the `SECRET_SIZE_PROP` property is already defined then we're not\n        // in the first call to `initMap` (e.g. coming from `map.clear()`) so\n        // all we need to do is reset the size without defining the properties.\n        if (map.hasOwnProperty(SECRET_SIZE_PROP)) {\n          map[SECRET_SIZE_PROP] = 0;\n        } else {\n          Object.defineProperty(map, SECRET_SIZE_PROP, {\n            value: 0,\n            writable: true,\n          });\n          Object.defineProperty(map, 'size', {\n            set: v => {\n              console.error(\n                'PLEASE FIX ME: You are changing the map size property which ' +\n                  'should not be writable and will break in production.',\n              );\n              throw new Error('The map size property is not writable.');\n            },\n            get: () => map[SECRET_SIZE_PROP],\n          });\n        }\n\n        // NOTE: Early return to implement immutable `.size` in DEV.\n        return;\n      }\n    }\n\n    // This is a diviation from the spec. `size` should be a getter on\n    // `Map.prototype`. However, we have to support IE8.\n    map.size = 0;\n  }\n\n  /**\n   * Check if something is an object.\n   *\n   * @param {*} o\n   * @return {boolean}\n   */\n  function isObject(o) {\n    return o != null && (typeof o === 'object' || typeof o === 'function');\n  }\n\n  /**\n   * Create an iteration object.\n   *\n   * @param {*} value\n   * @param {boolean} done\n   * @return {object}\n   */\n  function createIterResultObject(value, done) {\n    return {value, done};\n  }\n\n  // Are we in a legit ES5 environment. Spoiler alert: that doesn't include IE8.\n  const isES5 = (function() {\n    try {\n      Object.defineProperty({}, 'x', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  /**\n   * Check if an object can be extended.\n   *\n   * @param {object|array|function|regexp} o\n   * @return {boolean}\n   */\n  function isExtensible(o) {\n    if (!isES5) {\n      return true;\n    } else {\n      return Object.isExtensible(o);\n    }\n  }\n\n  /**\n   * IE has a `uniqueID` set on every DOM node. So we construct the hash from\n   * this uniqueID to avoid memory leaks and the IE cloneNode bug where it\n   * clones properties in addition to the attributes.\n   *\n   * @param {object} node\n   * @return {?string}\n   */\n  function getIENodeHash(node) {\n    let uniqueID;\n    switch (node.nodeType) {\n      case 1: // Element\n        uniqueID = node.uniqueID;\n        break;\n      case 9: // Document\n        uniqueID = node.documentElement.uniqueID;\n        break;\n      default:\n        return null;\n    }\n\n    if (uniqueID) {\n      return OLD_IE_HASH_PREFIX + uniqueID;\n    } else {\n      return null;\n    }\n  }\n\n  const getHash = (function() {\n    const propIsEnumerable = Object.prototype.propertyIsEnumerable;\n    const hashProperty = guid();\n    let hashCounter = 0;\n\n    /**\n     * Get the \"hash\" associated with an object.\n     *\n     * @param {object|array|function|regexp} o\n     * @return {number}\n     */\n    return function getHash(o) {\n      // eslint-disable-line no-shadow\n      if (o[hashProperty]) {\n        return o[hashProperty];\n      } else if (\n        !isES5 &&\n        o.propertyIsEnumerable &&\n        o.propertyIsEnumerable[hashProperty]\n      ) {\n        return o.propertyIsEnumerable[hashProperty];\n      } else if (!isES5 && isNode(o) && getIENodeHash(o)) {\n        return getIENodeHash(o);\n      } else if (!isES5 && o[hashProperty]) {\n        return o[hashProperty];\n      }\n\n      if (isExtensible(o)) {\n        hashCounter += 1;\n        if (isES5) {\n          Object.defineProperty(o, hashProperty, {\n            enumerable: false,\n            writable: false,\n            configurable: false,\n            value: hashCounter,\n          });\n        } else if (o.propertyIsEnumerable) {\n          // Since we can't define a non-enumerable property on the object\n          // we'll hijack one of the less-used non-enumerable properties to\n          // save our hash on it. Addiotionally, since this is a function it\n          // will not show up in `JSON.stringify` which is what we want.\n          o.propertyIsEnumerable = function() {\n            return propIsEnumerable.apply(this, arguments);\n          };\n          o.propertyIsEnumerable[hashProperty] = hashCounter;\n        } else if (isNode(o)) {\n          // At this point we couldn't get the IE `uniqueID` to use as a hash\n          // and we couldn't use a non-enumerable property to exploit the\n          // dontEnum bug so we simply add the `hashProperty` on the node\n          // itself.\n          o[hashProperty] = hashCounter;\n        } else {\n          throw new Error('Unable to set a non-enumerable property on object.');\n        }\n        return hashCounter;\n      } else {\n        throw new Error('Non-extensible objects are not allowed as keys.');\n      }\n    };\n  })();\n\n  return Map;\n})(Function('return this')()); // eslint-disable-line no-new-func\n"],"names":["_shouldPolyfillES6Collection","require","d","guid","isNode","toIterator","module","exports","global","undefined","Map","KIND_KEY","KIND_VALUE","KIND_KEY_VALUE","KEY_PREFIX","OLD_IE_HASH_PREFIX","iterable","_classCallCheck","this","isObject","TypeError","initMap","next","it","done","value","set","_createClass","key","index","getIndex","_mapData","setIndex","push","size","MapIterator","callback","thisArg","boundCallback","bind","mapData","i","length","entry","prototype","ITERATOR_SYMBOL","entries","map","kind","indexOf","Error","_map","_nextIndex","_kind","createIterResultObject","record","hash","getHash","_objectIndex","prefixedKey","_stringIndex","_otherIndex","shouldDelete","o","isES5","Object","defineProperty","e","isExtensible","getIENodeHash","node","uniqueID","nodeType","documentElement","propIsEnumerable","hashProperty","hashCounter","propertyIsEnumerable","enumerable","writable","configurable","apply","arguments","Function"],"mappings":"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","file":"97.js"}