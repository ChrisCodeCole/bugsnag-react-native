{"version":3,"sources":["/Users/jamielynch/repos/bugsnag-react-native/examples/plain/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js"],"sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n'use strict';\n\nconst AnimatedImplementation = require('AnimatedImplementation');\nconst React = require('React');\nconst StyleSheet = require('StyleSheet');\nconst View = require('View');\n\nimport type {LayoutEvent} from 'CoreEventTypes';\n\nconst AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\ntype Props = {\n  children?: React.Element<any>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: AnimatedImplementation.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n};\n\ntype State = {\n  measured: boolean,\n  layoutY: number,\n  layoutHeight: number,\n  nextHeaderLayoutY: ?number,\n};\n\nclass ScrollViewStickyHeader extends React.Component<Props, State> {\n  state = {\n    measured: false,\n    layoutY: 0,\n    layoutHeight: 0,\n    nextHeaderLayoutY: this.props.nextHeaderLayoutY,\n  };\n\n  setNextHeaderY(y: number) {\n    this.setState({nextHeaderLayoutY: y});\n  }\n\n  _onLayout = event => {\n    this.setState({\n      measured: true,\n      layoutY: event.nativeEvent.layout.y,\n      layoutHeight: event.nativeEvent.layout.height,\n    });\n\n    this.props.onLayout(event);\n    const child = React.Children.only(this.props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  render() {\n    const {inverted, scrollViewHeight} = this.props;\n    const {measured, layoutHeight, layoutY, nextHeaderLayoutY} = this.state;\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    const translateY = this.props.scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n    const child = React.Children.only(this.props.children);\n\n    return (\n      <AnimatedView\n        collapsable={false}\n        onLayout={this._onLayout}\n        style={[child.props.style, styles.header, {transform: [{translateY}]}]}>\n        {React.cloneElement(child, {\n          style: styles.fill, // We transfer the child style to the wrapper.\n          onLayout: undefined, // we call this manually through our this._onLayout\n        })}\n      </AnimatedView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nmodule.exports = ScrollViewStickyHeader;\n"],"names":["AnimatedImplementation","require","d","React","StyleSheet","View","AnimatedView","createAnimatedComponent","ScrollViewStickyHeader","state","measured","layoutY","layoutHeight","nextHeaderLayoutY","_this","props","_onLayout","event","setState","nativeEvent","layout","y","height","onLayout","child","Children","only","children","this","_this$props","inverted","scrollViewHeight","_this$state","inputRange","outputRange","stickStartPoint","push","collisionPoint","translateY","scrollAnimatedValue","interpolate","createElement","collapsable","style","styles","header","transform","cloneElement","fill","undefined","Component","create","zIndex","flex","module","exports"],"mappings":"4BASA,mEAEMA,EAAyBC,EAAOC,EAAA,IAChCC,EAAQF,EAAOC,EAAA,IACfE,EAAaH,EAAOC,EAAA,IACpBG,EAAOJ,EAAOC,EAAA,IAIdI,EAAeN,EAAuBO,wBAAwBF,GAqB9DG,gLACJC,OACEC,UAAU,EACVC,QAAS,EACTC,aAAc,EACdC,kBAAmBC,EAAKC,MAAMF,qBAOhCG,UAAY,SAAAC,GACVH,EAAKI,UACHR,UAAU,EACVC,QAASM,EAAME,YAAYC,OAAOC,EAClCT,aAAcK,EAAME,YAAYC,OAAOE,SAGzCR,EAAKC,MAAMQ,SAASN,GACpB,IAAMO,EAAQrB,EAAMsB,SAASC,KAAKZ,EAAKC,MAAMY,UACzCH,EAAMT,MAAMQ,UACdC,EAAMT,MAAMQ,SAASN,8DAdVI,GACbO,KAAKV,UAAUL,kBAAmBQ,qCAiB3B,IAAAQ,EAC8BD,KAAKb,MAAnCe,EADAD,EACAC,SAAUC,EADVF,EACUE,iBADVC,EAEsDJ,KAAKnB,MAA3DC,EAFAsB,EAEAtB,SAAUE,EAFVoB,EAEUpB,aAAcD,EAFxBqB,EAEwBrB,QAASE,EAFjCmB,EAEiCnB,kBAClCoB,IAA4B,EAAK,GACjCC,GAA8B,EAAG,GAEvC,GAAIxB,EACF,GAAIoB,GAeF,GAAwB,MAApBC,EAA0B,CAC5B,IAAMI,EAAkBxB,EAAUC,EAAemB,EACjD,GAAII,EAAkB,EAAG,CACvBF,EAAWG,KAAKD,GAChBD,EAAYE,KAAK,GACjBH,EAAWG,KAAKD,EAAkB,GAClCD,EAAYE,KAAK,GAGjB,IAAMC,GACHxB,GAAqB,GAAKD,EAAemB,EACxCM,EAAiBF,IACnBF,EAAWG,KAAKC,EAAgBA,EAAiB,GACjDH,EAAYE,KACVC,EAAiBF,EACjBE,EAAiBF,UAKpB,CAWLF,EAAWG,KAAKzB,GAChBuB,EAAYE,KAAK,GAGjB,IAAMC,GAAkBxB,GAAqB,GAAKD,EAC9CyB,GAAkB1B,GACpBsB,EAAWG,KAAKC,EAAgBA,EAAiB,GACjDH,EAAYE,KAAKC,EAAiB1B,EAAS0B,EAAiB1B,KAE5DsB,EAAWG,KAAKzB,EAAU,GAC1BuB,EAAYE,KAAK,IAKvB,IAAME,EAAaV,KAAKb,MAAMwB,oBAAoBC,aAChDP,WAAAA,EACAC,YAAAA,IAEIV,EAAQrB,EAAMsB,SAASC,KAAKE,KAAKb,MAAMY,UAE7C,OACExB,EAAAsC,cAACnC,GACCoC,aAAa,EACbnB,SAAUK,KAAKZ,UACf2B,OAAQnB,EAAMT,MAAM4B,MAAOC,EAAOC,QAASC,YAAaR,WAAAA,OACvDnC,EAAM4C,aAAavB,GAClBmB,MAAOC,EAAOI,KACdzB,cAAU0B,aA3GiB9C,EAAM+C,WAkHrCN,EAASxC,EAAW+C,QACxBN,QACEO,OAAQ,IAEVJ,MACEK,KAAM,KAIVC,EAAOC,QAAU/C","file":"246.js"}